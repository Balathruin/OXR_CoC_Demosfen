-- =======================================================================================
-- Remade by Tronex
-- Last modification: 2018/7/17
-- New Game menu + Ironman mode save killer + Setting up new games
-- =======================================================================================
--  adopted for Demosfen

--=======================================< Controls >=======================================--
local ico_size = 0.7
local ico_width = (device().width / device().height > (1024/768+0.01)) and 0.8 or 1
local ini = system_ini()
local ini_ico = ini_file("plugins\\player_portraits.ltx")
local ini_itm = ini_file("plugins\\new_game_loadouts.ltx")
local ini_map = ini_file("plugins\\player_start_locations.ltx")
local ini_opt = ini_file("plugins\\new_game_options.ltx")
local ini_eco = ini_file("misc\\economy_difficulty.ltx")
local gs = game.translate_string


--=======================================< Callbacks >=======================================--
local spawn_path, start_pos
local function on_game_load(binder)
	local config = axr_main.config
	if not (config) then
		return
	end

	local se_actor = alife():actor()
	local need_save
	
	-- Gameplay Options
	if (USE_MARSHAL) then
		if (config:r_value("character_creation","new_game_hardcore_mode",1) == true) then
			-- shitty way to make a uuid but should be good enough to track the same saves
			alife_storage_manager.get_state().uuid = GAME_VERSION .. "_" .. tostring(math.random(100)) .. tostring(math.random()) .. tostring(math.random(1000))
			alife_storage_manager.get_state().death_limit = config:r_value("character_creation","new_game_hardcore_mode_lives",2) or 1
			alife_storage_manager.get_state().ironman_life_cycle = config:r_value("character_creation","new_game_hardcore_mode_regenerate",2)
			alife_storage_manager.get_state().ironman_life_feature = config:r_value("character_creation","new_game_hardcore_mode_regenerate",2) and true or nil
			config:w_value("character_creation","new_game_hardcore_mode")
			config:w_value("character_creation","new_game_hardcore_mode_lives")
			config:w_value("character_creation","new_game_hardcore_mode_regenerate")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_survival_mode",1) == true) then
			alife_storage_manager.get_state().enable_survival_mode = true
			config:w_value("character_creation","new_game_survival_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_azazel_mode",1) == true) then
			alife_storage_manager.get_state().enable_azazel_mode = true
			config:w_value("character_creation","new_game_azazel_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_campfire_mode",1) == true) then
			alife_storage_manager.get_state().enable_campfire_mode = true
			config:w_value("character_creation","new_game_campfire_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_conditions_mode",1) == true) then
			alife_storage_manager.get_state().enable_conditions_mode = true
			config:w_value("character_creation","new_game_conditions_mode")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_timer_mode",2)) then
			alife_storage_manager.get_state().enable_timer_mode = config:r_value("character_creation","new_game_timer_mode",2)
			config:w_value("character_creation","new_game_timer_mode")
			need_save = true
		end
		
		
		if (config:r_value("character_creation","new_game_difficulty",3)) then
			local diff = config:r_value("character_creation","new_game_difficulty",3) or "stalker"
			local console = get_console()
			console:execute("g_game_difficulty gd_" .. diff)
			config:w_value("character_creation","new_game_difficulty")
			need_save = true
		end
		
		if (config:r_value("character_creation","new_game_economy_goodwill",2)) then
			alife_storage_manager.get_state().economy_goodwill = config:r_value("character_creation","new_game_economy_goodwill",2)
			config:w_value("character_creation","new_game_economy_goodwill")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_economy_money",2)) then
			alife_storage_manager.get_state().economy_money = config:r_value("character_creation","new_game_economy_money",2)
			config:w_value("character_creation","new_game_economy_money")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_economy_wpn",2)) then
			alife_storage_manager.get_state().economy_wpn = config:r_value("character_creation","new_game_economy_wpn",2)
			config:w_value("character_creation","new_game_economy_wpn")
			need_save = true
		end
		if (config:r_value("character_creation","new_game_economy_loot",2)) then
			alife_storage_manager.get_state().economy_loot = config:r_value("character_creation","new_game_economy_loot",2)
			config:w_value("character_creation","new_game_economy_loot")
			need_save = true
		end
		
	end
	
	-- NEW CHARACTER NAME
	local new_character_name = config:r_value("character_creation","new_game_character_name",3) or ""
	if (new_character_name and new_character_name ~= "") then
		config:w_value("character_creation","new_game_character_name")
		need_save = true
		
		new_character_name = new_character_name:gsub("_"," ")

		se_actor:set_character_name(new_character_name)
	end
	
	-- NEW CHARACTER ICON
	local new_character_icon = config:r_value("character_creation","new_game_icon",3)
	if (new_character_icon and new_character_icon ~= "") then
		db.actor_binder.character_icon = new_character_icon
		
		config:w_value("character_creation","new_game_icon")
		need_save = true
	end
	
	-- NEW FACTION
	local faction = config:r_value("character_creation","new_game_faction",3) or ""

	-- Check if DRX Questlines addon is available
	local drx_ini = ini_file("misc\\task_manager.ltx")
	local drx = drx_ini:section_exist("drx_sl_find_wish_granter_task") and true or false
	
	if (faction and faction ~= "") then
		config:w_value("character_creation","new_game_faction")
		need_save = true
		
		-- Faction Spawn Position
		local start_location = config:r_value("character_creation","new_game_map")
		config:w_value("character_creation","new_game_map")
		
		if start_location and start_location ~= "" then
			start_pos = {}
			table.insert(start_pos,ini_map:r_float_ex(start_location, "lvid"))
			table.insert(start_pos,ini_map:r_float_ex(start_location, "gvid"))
			table.insert(start_pos,vector():set(ini_map:r_float_ex(start_location,"x"),ini_map:r_float_ex(start_location,"y"),ini_map:r_float_ex(start_location,"z")))
		else
			spawn_path = nil  --patrol("spawn_player_"..faction)
		end
		
		
		-- Only give the story quests to factions in this table.
		local story_factions = {
			["csky"] = true,
			["dolg"] = true,
			["ecolog"] = true,
			["freedom"] = true,
			["killer"] = true,
			["stalker"] = true,
		}
		
		-- Enable the story quests, or disable their components depending on player choice and faction.
		if (config:r_value("character_creation","new_game_story_mode",1) == true and story_factions[faction] and not has_alife_info("story_mode_disabled")) then
			task_manager.get_task_manager():give_task("mar_find_doctor_task") -- main quest
			task_manager.get_task_manager():give_task("turn_off_brain_scorcher") -- brain scorcher quest
			task_manager.get_task_manager():give_task("turn_off_brain_machine") -- miracle machine quest
		
		-- If Azazel mode is choosen, disable story, Drx Questlines and all psi-generators
		elseif (alife_storage_manager.get_state().enable_azazel_mode) then
			-- Compatibility with many story-specific mechanics.
			give_info("story_mode_disabled")
			-- Turn off the Miracle Machine:
			give_info("yan_labx16_switcher_1_off")
			give_info("yan_labx16_switcher_2_off")
			give_info("yan_labx16_switcher_3_off")
			give_info("yan_labx16_switcher_primary_off")

			-- Turn off the Brain Scorcher:
			give_info("bar_deactivate_radar_done")

			-- Turn off the Generators:
			give_info("warlab_deactivate_generators_done")
		
		else 
			-- Compatibility with many story-specific mechanics.
			give_info("story_mode_disabled")
			
			-- Give deactivate Brain Scorcher task:
			if ( faction ~= "monolith" ) and drx then
				task_manager.get_task_manager( ):give_task( "turn_off_brain_scorcher" )
			else
	
				-- Turn off the Miracle Machine:
				give_info("yan_labx16_switcher_1_off")
				give_info("yan_labx16_switcher_2_off")
				give_info("yan_labx16_switcher_3_off")
				give_info("yan_labx16_switcher_primary_off")
	
				-- Turn off the Brain Scorcher:
				give_info("bar_deactivate_radar_done")
	
				-- Turn off the Generators:
				give_info("warlab_deactivate_generators_done")
	
			end
			
			if drx then
				-- Determine total number of storyline tasks to complete for this game:
				alun_utils.save_var( db.actor, "drx_sl_total_task_number", math.random( 8, 12 ) )  -- Set to range of total meet honcho tasks to complete to finish game
				alun_utils.save_var( db.actor, "drx_sl_current_task_number", 1 )
	
				-- Determine first honcho to start at:
				local start_game_honcho = ""
				if ( faction == "stalker" ) then
					start_game_honcho = "esc_m_trader"  -- Loner, Sidorovich
				elseif ( faction == "dolg" ) then
					start_game_honcho = "bar_dolg_general_petrenko_stalker"  -- Duty, Petrenko
				elseif ( faction == "freedom" ) then
					start_game_honcho = "mil_smart_terrain_7_7_freedom_leader_stalker"  -- Freedom, Lukash
				elseif ( faction == "csky" ) then
					start_game_honcho = "mar_smart_terrain_base_stalker_leader_marsh"  -- Clear Sky, Cold
				elseif ( faction == "ecolog" ) then
					start_game_honcho = "yan_stalker_sakharov"  -- Ecologist, Sakharov
				elseif ( faction == "killer" ) then
					start_game_honcho = "cit_killers_merc_trader_stalker"  -- Mercenary, Dushman
				elseif ( faction == "army" ) then
					start_game_honcho = "agr_smart_terrain_1_6_near_2_military_colonel_kovalski"  -- Military, Kuznetsov
				elseif ( faction == "bandit" ) then
					start_game_honcho = "zat_b7_bandit_boss_sultan"  -- Bandit, Sultan
				elseif ( faction == "monolith" ) then
					start_game_honcho = "pri_monolith_monolith_trader_stalker"  -- Monolith, Rabbit
				else
					printf( "DRX SL no available game start honchos !!" )
				end
	
				-- Build list of available start game versions for start game honcho:
				honcho_start_ltx_file = ini_file("misc\\task_manager.ltx")
				local honcho_start_list = {}
				local honcho_start_id = ""
				local i = 1
				while ( true ) do
					honcho_start_id = ("drx_sl_" .. start_game_honcho .. "_start_game_" .. i)
					if ( honcho_start_ltx_file:section_exist( honcho_start_id ) ) then
						table.insert( honcho_start_list, honcho_start_id )
						i = (i + 1)
					else
						break
					end
				end
	
				-- Send actor to start game at current honcho:
				if ( #honcho_start_list > 0 ) then
					math.randomseed( device( ):time_global( ) )
					honcho_start_id = honcho_start_list[math.random( #honcho_start_list )]
					printf( ("DRX SL current storyline task: " .. honcho_start_id) )
					alun_utils.save_var( db.actor, "drx_sl_start_task", honcho_start_id )
					alun_utils.save_var( db.actor, "drx_sl_current_honcho", start_game_honcho )
					give_info( ("drx_sl_start_game_" .. start_game_honcho) )  -- (\configs\gameplay\info_portions.xml)
					task_manager.get_task_manager( ):give_task( honcho_start_id )
				else
					printf( ("DRX SL no start game tasks available for " .. start_game_honcho .. " !!") )
				end
			end
		end
		config:w_value("character_creation","new_game_story_mode") -- clear value
		
		db.actor:set_character_community("actor_" .. faction, 0, 0)
		
		--Debrovski: Bug here?
		-- Reset player goodwill
		--local communities = alun_utils.get_communities_list( )		
		--for community,_ in pairs( communities ) do
		--	relation_registry.set_community_goodwill( community, 0, 0 )
		--end
		
		-- Money
		local money = config:r_value("character_creation","new_game_money",2)
		if money and money ~= "" then
			db.actor:give_money(-db.actor:money()+money)
		end 
		config:w_value("character_creation","new_game_money")
		
		
		-- Loadout
		local sim = alife()
		local loadout = config:r_value("character_creation","new_game_loadout",3)
		local ammo_table = {}
		if loadout and loadout ~= "" then
			local t = alun_utils.str_explode(loadout,",")
			for i=1, #t do
				if ini:section_exist(t[i]) then
					if ini:r_string_ex(t[i],"ammo_class") then
						local slot = ini:r_float_ex(t[i],"slot")
						if slot and ((slot == 1) or (slot == 2)) then -- retarded way to know that we are dealing with weapon
							local ammo = ini:r_string_ex(t[i],"ammo_class")
							ammo = alun_utils.str_explode(ammo,",")
							ammo = ammo[1] --ammo[math.random(#ammo)]
							local box_size = (ini:r_float_ex(ammo, "box_size") or 50)
							local count = (box_size < 30) and 2 or 1
							for j = 1, count do
								ammo_table[#ammo_table + 1] = ammo
							end
						end
					end
					sim:create(t[i],db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),0)
				end
			end
		end
		for i = 1, #ammo_table do
			sim:create(ammo_table[i],db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),0)
		end
		config:w_value("character_creation","new_game_loadout")
		
		se_actor:set_profile_name("actor_"..faction)
		-- mlr
		if not mlr_utils.load_var('transitions_faction') then
			mlr_utils.save_var('transitions_faction', faction)
		end
		-- mlr
	end
	
	-- Loading economy values from save file
	axr_main.config:w_value("mm_options","multi_rewards_goodwill", utils.round(alife_storage_manager.get_state().economy_goodwill,2))
	axr_main.config:w_value("mm_options","multi_rewards_money", utils.round(alife_storage_manager.get_state().economy_money,2))
	axr_main.config:w_value("mm_options","multi_wpn_conditions", utils.round(alife_storage_manager.get_state().economy_wpn,2))
	axr_main.config:w_value("mm_options","multi_loot", utils.round(alife_storage_manager.get_state().economy_loot,2))
	
	if (need_save) then
		config:save()
	end
end

local function actor_on_first_update(binder,delta)
	if (spawn_path) then
		start_pos = {}
		start_pos[1] = spawn_path:level_vertex_id(0)
		start_pos[2] = spawn_path:game_vertex_id(0)
		start_pos[3] = spawn_path:point(0)
	end
	
	-- Survival mode
	if (IsSurvivalMode()) then
		game_relations.change_factions_community_num("zombied",0,-5000)
		game_relations.change_factions_community_num("monolith",0,-5000)

		local faction = character_community(db.actor):sub(7)
		if (ini:section_exist("survival_squad_"..faction) and start_pos) then
			local sim = alife()
			local squad = sim:create("survival_squad_"..faction,start_pos[3],start_pos[1],start_pos[2])
			if (squad) then
				axr_companions.companion_squads[squad.id] = squad
				squad:create_npc(nil,start_pos[3],start_pos[1],start_pos[2])
				local as
				for k in squad:squad_members() do
					local se_obj = k.object or k.id and sim:object(k.id)
					if (se_obj) then
						game_relations.change_factions_community_num("zombied",k.id,-5000)
						SIMBOARD:setup_squad_and_group(se_obj)
						
						utils.se_obj_save_var(se_obj.id,se_obj:name(),"companion",true)
						utils.se_obj_save_var(se_obj.id,se_obj:name(),"companion_cannot_dismiss",true)
					end
				end
			end
		end
	end

	if start_pos and #start_pos == 3 then
		ChangeLevel(start_pos[3],start_pos[1],start_pos[2],VEC_ZERO)
	end
end

local function actor_on_before_death() -- Ironman: second wind
	if not (USE_MARSHAL) then
		return
	end
	
	local uuid = alife_storage_manager.get_state().uuid
	if not (uuid) then
		return -- not in hardcore mode
	end
	
	local fs = getFS()
	local flist = fs:file_list_open_ex("$game_saves$",bit_or(FS.FS_ListFiles,FS.FS_RootOnly),"*.scoc")
	local f_cnt = flist:Size()

	for	it=0, f_cnt-1 	do
		local file = flist:GetAt(it)
		local file_name = string.sub(file:NameFull(), 0, (string.len(file:NameFull()) - string.len(".scoc")))

		--printf("file_name = %s",file_name)
		local path = fs:update_path('$game_saves$', '')..file_name..".scoc"
		local f = io.open(path,"rb")
		if (f) then
			local data = f:read("*all")
			f:close()
			if (data) then
				local decoded = alife_storage_manager.decode(data)
				if (decoded and decoded.uuid == uuid) then
					decoded.death_limit = decoded.death_limit or 3
					decoded.death_count = (decoded.death_count or 0) + 1
					if (decoded.death_count >= decoded.death_limit) then
						ui_load_dialog.delete_save_game(file_name)	
					else
						local f = io.open(path,"wb")
						if (f) then
							local encoded = marshal.encode(decoded)
							if (encoded) then 
								f:write(encoded)
							end
							f:close()
						end
					end
				end
			end
		end
	end
end

------------------
-- on_game_start()
------------------
function on_game_start()
	RegisterScriptCallback("on_game_load",on_game_load)
	RegisterScriptCallback("actor_on_before_death",actor_on_before_death)
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update,true)
end

--------------------------------------------------------------
-- faction_ui
--------------------------------------------------------------

--==============================================================================--
-------------------------------------< GUI >--------------------------------------
--==============================================================================--
class "faction_ui" (CUIScriptWnd)

function faction_ui:__init(owner) super()
	self.owner = owner

	-- Tables
	self.table_faction = {"stalker","bandit","csky","dolg","freedom","killer","army","ecolog","monolith"}
	self.table_icon = {}
	self.table_map = {}
	self.table_loadout = {}
	self.table_inv = {}
	self.table_difficulty = {"novice","stalker","veteran","master"}
	self.table_economy = {"st_econ_1","st_econ_2","st_econ_3","st_econ_4"}
	
	self.table_hardcore_lives = {}
	local n = ini_opt:line_count("new_game_hardcore_lives") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_hardcore_lives",i,"","" )
		local t = alun_utils.str_explode(value,",")
		local size = #self.table_hardcore_lives + 1
		self.table_hardcore_lives[size] = {}
		self.table_hardcore_lives[size][1] = tonumber(t[1])
		self.table_hardcore_lives[size][2] = tostring(t[2])
	end
	
	self.table_hardcore_regen = {{nil,"st_off"}}
	local n = ini_opt:line_count("new_game_hardcore_regen") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_hardcore_regen",i,"","" )
		local t = alun_utils.str_explode(value,",")
		local size = #self.table_hardcore_regen + 1
		self.table_hardcore_regen[size] = {}
		self.table_hardcore_regen[size][1] = tonumber(t[1])
		self.table_hardcore_regen[size][2] = tostring(t[2])
	end
	
	self.table_timer = {{nil,"st_off"}}
	local n = ini_opt:line_count("new_game_timer") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_timer",i,"","" )
		local t = alun_utils.str_explode(value,",")
		local size = #self.table_timer + 1
		self.table_timer[size] = {}
		self.table_timer[size][1] = tonumber(t[1])
		self.table_timer[size][2] = tostring(t[2])
	end
	
	-- Selected choices
	self.selected_faction = self.table_faction[1]
	self.selected_icon = nil
	self.selected_map = nil
	self.selected_money = nil
	self.selected_difficulty = self.table_difficulty[2]
	self.selected_economy = self.table_economy[2]
	self.selected_hardcore_lives = self.table_hardcore_lives[1]
	self.selected_hardcore_regen = self.table_hardcore_regen[1]
	self.selected_timer = self.table_timer[1]
	self.points_left = ini_itm:r_float_ex("points","total_points") or 1000
	self.points_used = 0
	
	-- Utility
	self.access	= true
	
	-- Prepare
	self:SetWndRect				(Frect():set(0,0,1024,768))
	self:Enable					(true)

	local xml					= CScriptXmlInit()
	self.xml = xml
	xml:ParseFile				("ui_mm_faction_select.xml")

	xml:InitStatic				("background", self)
	
	-- Main
	self:Main_Controls()
	self:Main_CallBacks()
	
	-- Faction Select
	self:PopupFaction_Controls()
	self:PopupFaction_Callbacks()
	self:PopupFaction_Show(false)
	
	-- Icon Select
	self:PopupIcon_Controls()
	self:PopupIcon_Callbacks()
	self:PopupIcon_Show(false)
end

function faction_ui:__finalize()

end

function faction_ui:Main_Controls()
	local xml = self.xml
	
	-- Background
	self.dialog					= xml:InitStatic("main_dialog:frame_back", self)
	
	
	-- Boxes
	self.box_map = xml:InitStatic("main_dialog:box_map",self.dialog)
	self.box_faction = xml:InitStatic("main_dialog:box_faction",self.dialog)
	self.box_icon = xml:InitStatic("main_dialog:box_icon",self.dialog)
	
	self.box_item = xml:InitStatic("main_dialog:box_item",self.dialog)
	self.box_item_temp = xml:InitStatic("main_dialog:box_item",self.dialog)
	
	
	-- Main frame
	self.main_frame = xml:InitStatic("main_dialog:frame_front",self.dialog)
	
	
	-- Interactive Text
	self.text_descr = xml:InitTextWnd("main_dialog:text_descr",nil)
	self.scroll_desc = xml:InitScrollView("main_dialog:scroll_desc", self.dialog)
	self.scroll_desc:AddWindow(self.text_descr, true)
	self.text_descr:SetAutoDelete(false)
	
	self.character_name = xml:InitEditBox("main_dialog:input_name",self.dialog)
	self:Register(self.character_name,"input_name")
	self.character_name:SetText(gs("no_name_name")) -- Set Default Name
	
	self.text_relations = xml:InitTextWnd("main_dialog:text_relations",self.dialog)
	self.text_money = xml:InitTextWnd("main_dialog:text_money",self.dialog)
	self.text_points_left = xml:InitTextWnd("main_dialog:text_points_left",self.dialog)
	self.text_points_used = xml:InitTextWnd("main_dialog:text_points_used",self.dialog)
	
	self.text_item_descr = xml:InitTextWnd("main_dialog:text_item_descr",nil)
	self.scroll_item_desc = xml:InitScrollView("main_dialog:scroll_item_desc", self.dialog)
	self.scroll_item_desc:AddWindow(self.text_item_descr, true)
	self.text_item_descr:SetAutoDelete(false)
	
	self.text_item_name = xml:InitTextWnd("main_dialog:text_item_name",self.dialog)
	self.text_item_points = xml:InitTextWnd("main_dialog:text_item_points",self.dialog)
	
	
	-- Static Text
	xml:InitStatic("main_dialog:cap_character",self.dialog)
	xml:InitStatic("main_dialog:cap_options",self.dialog)
	xml:InitStatic("main_dialog:cap_inventory",self.dialog)
	xml:InitStatic("main_dialog:cap_loadout",self.dialog)
	
	xml:InitStatic("main_dialog:cap_name",self.dialog)
	xml:InitStatic("main_dialog:cap_money",self.dialog)
	xml:InitStatic("main_dialog:cap_points_left",self.dialog)
	xml:InitStatic("main_dialog:cap_points_used",self.dialog)
	
	
	-- Main Buttons
	local btn = xml:Init3tButton("main_dialog:btn_start", self.dialog)
	self:Register(btn,"btn_start")
	
	btn = xml:Init3tButton("main_dialog:btn_back", self.dialog)
	self:Register(btn,"btn_back")
	
	btn = xml:Init3tButton("main_dialog:btn_random", self.dialog)
	self:Register(btn,"btn_random")
	
	btn = xml:Init3tButton("main_dialog:btn_faction", self.dialog)
	self:Register(btn,"btn_faction")
	
	btn = xml:Init3tButton("main_dialog:btn_icon", self.dialog)
	self:Register(btn,"btn_icon")
	
	self.list_map = xml:InitComboBox("main_dialog:list_map", self.dialog)
	self.list_map:SetAutoDelete(true)
	self:Register(self.list_map, "list_map")
	
	
	-- Item Lists
	self.list_inv = xml:InitListBox("main_dialog:list_inv",self.dialog)
	self.list_inv:ShowSelectedItem(true)
	self.list_inv:Show(true)
	self:Register(self.list_inv, "list_inv")
	
	self.list_loadout = xml:InitListBox("main_dialog:list_loadout",self.dialog)
	self.list_loadout:ShowSelectedItem(true)
	self.list_loadout:Show(true)
	self:Register(self.list_loadout, "list_loadout")
	
	self.ck_reset = xml:Init3tButton("main_dialog:check_reset", self.dialog)
	self:Register(self.ck_reset,"check_reset")
	
	
	-- Update info
	self:UpdateAll(false)

	-- Options
	self.scroll_options = xml:InitScrollView("main_dialog:scroll_options", self.dialog)
	self.templ_options = xml:InitStatic("main_dialog:templ_options",nil)
	if (USE_MARSHAL) then
		self.list_difficulty_cap = xml:InitStatic("main_dialog:list_difficulty_cap",self.dialog)
		self.list_difficulty = xml:InitComboBox("main_dialog:list_difficulty", self.dialog)
		self.list_difficulty:SetAutoDelete(true)
		self:Register(self.list_difficulty, "list_difficulty")
		self:LoadDifficulty()
		
		self.list_economy_cap = xml:InitStatic("main_dialog:list_economy_cap",self.dialog)
		self.list_economy = xml:InitComboBox("main_dialog:list_economy", self.dialog)
		self.list_economy:SetAutoDelete(true)
		self:Register(self.list_economy, "list_economy")
		self:LoadEconomy()
		
		self.ck_story_cap = xml:InitStatic("main_dialog:options:cap_check_story",self.templ_options)
		self.ck_story = xml:InitCheck("main_dialog:options:check_story",	self.templ_options)
		self:Register(self.ck_story,"check_story")
		
		self.ck_hardcore_cap = xml:InitStatic("main_dialog:options:cap_check_hardcore",self.templ_options)
		self.ck_hardcore = xml:InitCheck("main_dialog:options:check_hardcore",	self.templ_options)
		self:Register(self.ck_hardcore,"check_hardcore")
		
		self.ck_azazel_mode_cap = xml:InitStatic("main_dialog:options:cap_check_azazel_mode",self.templ_options)
		self.ck_azazel_mode = xml:InitCheck("main_dialog:options:check_azazel_mode",	self.templ_options)
		self:Register(self.ck_azazel_mode,"check_azazel_mode")
		
		self.ck_survival_cap = xml:InitStatic("main_dialog:options:cap_check_survival",self.templ_options)
		self.ck_survival = xml:InitCheck("main_dialog:options:check_survival",	self.templ_options)
		self:Register(self.ck_survival,"check_survival")
		
		self.ck_campfire_cap = xml:InitStatic("main_dialog:options:cap_check_campfire",self.templ_options)
		self.ck_campfire = xml:InitCheck("main_dialog:options:check_campfire",	self.templ_options)
		self:Register(self.ck_campfire,"check_campfire")
		
		self.ck_conditions_cap = xml:InitStatic("main_dialog:options:cap_check_conditions",self.templ_options)
		self.ck_conditions = xml:InitCheck("main_dialog:options:check_conditions",	self.templ_options)
		self:Register(self.ck_conditions,"check_conditions")
		
		self.list_hardcore_lives_cap = xml:InitStatic("main_dialog:options:cap_list_hardcore_lives",self.templ_options)
		self.list_hardcore_lives = xml:InitComboBox("main_dialog:options:list_hardcore_lives", self.templ_options)
		self.list_hardcore_lives:SetAutoDelete(true)
		self:Register(self.list_hardcore_lives, "list_hardcore_lives")
		self:LoadHardcoreLives()
		
		self.list_hardcore_regen_cap = xml:InitStatic("main_dialog:options:cap_list_hardcore_regen",self.templ_options)
		self.list_hardcore_regen = xml:InitComboBox("main_dialog:options:list_hardcore_regen", self.templ_options)
		self.list_hardcore_regen:SetAutoDelete(true)
		self:Register(self.list_hardcore_regen, "list_hardcore_regen")
		self:LoadHardcoreRegen()
		
		self.list_timer_cap = xml:InitStatic("main_dialog:options:cap_list_timer",self.templ_options)
		self.list_timer = xml:InitComboBox("main_dialog:options:list_timer", self.templ_options)
		self.list_timer:SetAutoDelete(true)
		self:Register(self.list_timer, "list_timer")
		self:LoadTimer()
		
		self.ck_states = { 	
							--["box_faction"] = false,
							--["box_icon"] = false,
							--["list_map"] = false,
							--["ck_reset"] = false,
		
							["ck_survival"] = false,
							["ck_hardcore"] = false,
							["ck_azazel_mode"] = false,
							["ck_story"] = false,
							["ck_campfire"] = false,
							["ck_conditions"] = false,
							
							["list_difficulty"] = false,
							["list_economy"] = false,
							["list_hardcore_lives"] = false,
							["list_hardcore_regen"] = false,
							["list_timer"] = false
		}
	end
	self.scroll_options:AddWindow(self.templ_options, true)
	self.templ_options:SetAutoDelete(false)
	
	
	-- Hint Window
	self.hint_wnd = xml:InitFrame("hint_wnd:background",self)
	self.hint_wnd:SetAutoDelete(false)
	self.hint_wnd_text = xml:InitTextWnd("hint_wnd:text",self.hint_wnd)
	self.hint_wnd:Show(false)
	
	-- Message Window 
	self.msg_wnd = xml:InitFrame("hint_wnd:background",self)
	self.msg_wnd:SetAutoDelete(false)
	self.msg_wnd_text = xml:InitTextWnd("hint_wnd:text",self.msg_wnd)
	self.msg_wnd_text:SetTextAlignment(2)
	
	self.msg_wnd:Show(false)
	self.msg_wnd:SetColor(GetARGB(255,0,0,0))
end

function faction_ui:Main_CallBacks()
	self:AddCallback("btn_start", ui_events.BUTTON_CLICKED, self.OnStartGame, self)
	self:AddCallback("btn_random", ui_events.BUTTON_CLICKED, self.OnRandomize, self)
	self:AddCallback("btn_back", ui_events.BUTTON_CLICKED, self.OnQuit, self)
	
	self:AddCallback("btn_faction", ui_events.BUTTON_CLICKED, self.OnFactionClicked, self)
	self:AddCallback("btn_icon", ui_events.BUTTON_CLICKED, self.OnIconClicked, self)
	
	self:AddCallback("list_map", ui_events.LIST_ITEM_SELECT, self.OnSelectMap, self)
	self:AddCallback("check_reset", ui_events.BUTTON_CLICKED, self.OnCheckResetList, self)
	
	self:AddCallback("list_inv", ui_events.LIST_ITEM_CLICKED, self.OnInventoryClicked, self)
	self:AddCallback("list_inv", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnInventoryDbClicked, self)
	self:AddCallback("list_loadout", ui_events.LIST_ITEM_CLICKED, self.OnLoadoutClicked, self)
	self:AddCallback("list_loadout", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnLoadoutDbClicked, self)
	
	self:AddCallback("check_story", ui_events.BUTTON_CLICKED, self.OnCheckSetStory, self)
	self:AddCallback("check_azazel_mode", ui_events.BUTTON_CLICKED, self.OnCheckSetAzazel, self)
	self:AddCallback("list_difficulty", ui_events.LIST_ITEM_SELECT, self.OnSelectDifficulty, self)
	self:AddCallback("list_economy", ui_events.LIST_ITEM_SELECT, self.OnSelectEconomy, self)
	self:AddCallback("list_hardcore_lives", ui_events.LIST_ITEM_SELECT, self.OnSelectHardcoreLives, self)
	self:AddCallback("list_hardcore_regen", ui_events.LIST_ITEM_SELECT, self.OnSelectHardcoreRegen, self)
	self:AddCallback("list_timer", ui_events.LIST_ITEM_SELECT, self.OnSelectTimer, self)
end

function faction_ui:Update()
	CUIScriptWnd.Update(self)
	
	if (not self.access) then
		self.hint_wnd:Show(false)
		return
	end
	
	-- Warning messages timer 
	if (self.msg_wnd_timer and time_global() > self.msg_wnd_timer) then 
		self.msg_wnd_timer = nil
		self.msg_wnd:Show(false)
	end
	
	for ck_name,v in pairs(self.ck_states) do 
		if (self[ck_name] and self[ck_name]:IsCursorOverWindow()) then
			local str = ""
			if (ck_name == "box_faction") then
				str = strformat( gs("st_mm_box_faction_desc") , gs("st_faction_" .. self.selected_faction))
				if (self.selected_faction == "bandit") then
					str = "cheeki breeki"
				end
			else
				str = gs("st_mm_"..ck_name.."_desc")
			end
			self:SetHint(str)
			return
		end
	end
	self.hint_wnd:Show(false)
end 

function faction_ui:SetMsg(text,tmr)
	if (text == "") then 
		return 
	end
	self.msg_wnd:Show(true)
	self.msg_wnd_text:SetText(text)
	self.msg_wnd_text:AdjustHeightToText()
	self.msg_wnd_text:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+10))
	self.msg_wnd_text:SetWndPos(vector2():set(0,20))
	
	self.msg_wnd:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+44))
	self.msg_wnd:SetWndPos(vector2():set(0,80))

	self.msg_wnd_timer = time_global() + 1000*tmr
end

function faction_ui:SetHint(text,pos)
	if (text == "") then
		return
	end
	self.hint_wnd:Show(true)
	self.hint_wnd_text:SetText(text)
	self.hint_wnd_text:AdjustHeightToText()
	self.hint_wnd:SetWndSize(vector2():set(self.hint_wnd:GetWidth(),self.hint_wnd_text:GetHeight()+44))
	
	pos = pos or GetCursorPosition()
	pos.y = pos.y - self.hint_wnd:GetHeight()
	pos.x = pos.x - self.hint_wnd:GetWidth()
	self.hint_wnd:SetWndPos(pos)
	
	FitInRect(self.hint_wnd,Frect():set(0,0,1024,768),0,100)
end


--=======================================< Faction Select Pop-up >=======================================--
function faction_ui:PopupFaction_Controls()
	local xml = self.xml

	-- Main
	self.black_1					= xml:InitStatic("main_dialog:popup_faction:frame_black",self.dialog)
	self.dialog_1					= xml:InitStatic("main_dialog:popup_faction:frame", self.dialog)
	
	-- Static Text
	self.cap_faction = xml:InitStatic("main_dialog:popup_faction:cap_faction",self.dialog_1)
	
	-- Faction buttons
	self.scroll_faction = xml:InitScrollView("main_dialog:popup_faction:scroll_faction", self.dialog_1)
	self.templ_faction = xml:InitStatic("main_dialog:popup_faction:templ_faction",nil)
	self.btn_faction = {}
	
end

function faction_ui:PopupFaction_Callbacks()
	for i = 1 , #self.table_faction do
		self:AddCallback("btn_" .. self.table_faction[i], ui_events.BUTTON_CLICKED, self["OnFaction_"..self.table_faction[i]], self)
	end
end

function faction_ui:PopupFaction_Show (state)
	local xml = self.xml
	
	self.black_1:Show(state)
	self.dialog_1:Show(state)
	self.cap_faction:Show(state)
	self.scroll_faction:Clear()
	if state then
		self.access = false
		
		for i = 1 , #self.table_faction do
			self.btn_faction[i] = xml:Init3tButton("main_dialog:popup_faction:btn_" .. self.table_faction[i] , self.templ_faction)
			local x,y = self:GetAxis_Icon ( self.scroll_faction, self.btn_faction[i], 3, 3, math.ceil(i/3), (i>3 and i<7 and i-3) or (i>6 and i-6) or i )
			self.btn_faction[i]:SetWndPos(vector2():set(x, y))
			self:Register(self.btn_faction[i], "btn_" .. self.table_faction[i] )
		end
		self.scroll_faction:AddWindow(self.templ_faction, true)
		self.templ_faction:SetAutoDelete(false)
		
	else
		self.access = true
	end
end

function faction_ui:OnFactionSelect(faction)
	self.selected_faction = faction
	self:UpdateAll(false, self.selected_faction)
	self:PopupFaction_Show(false)
end

function faction_ui:OnFaction_stalker()
	self:OnFactionSelect("stalker")
end
function faction_ui:OnFaction_bandit()
	self:OnFactionSelect("bandit")
end
function faction_ui:OnFaction_csky()
	self:OnFactionSelect("csky")
end
function faction_ui:OnFaction_dolg()
	self:OnFactionSelect("dolg")
end
function faction_ui:OnFaction_freedom()
	self:OnFactionSelect("freedom")
end
function faction_ui:OnFaction_killer()
	self:OnFactionSelect("killer")
end
function faction_ui:OnFaction_army()
	self:OnFactionSelect("army")
end
function faction_ui:OnFaction_ecolog()
	self:OnFactionSelect("ecolog")
end
function faction_ui:OnFaction_monolith()
	self:OnFactionSelect("monolith")
end


--=======================================< Icon Select Pop-up >=======================================--
function faction_ui:PopupIcon_Controls()
	local xml = self.xml
	
	-- Main
	self.black_2					= xml:InitStatic("main_dialog:popup_icon:frame_black",self.dialog)
	self.dialog_2					= xml:InitStatic("main_dialog:popup_icon:frame", self.dialog)
	
	-- Static Text
	self.cap_icon = xml:InitStatic("main_dialog:popup_icon:cap_icon",self.dialog_2)
	
	-- Faction buttons
	self.scroll_icon = xml:InitScrollView("main_dialog:popup_icon:scroll_icon", self.dialog_2)
	self.templ_icon = xml:InitStatic("main_dialog:popup_icon:templ_icon",nil)
	
	-- Size Reference
	self.tempy_icon = xml:InitStatic("main_dialog:popup_icon:temp_icon" , self.dialog_2)
	
	self.btn_icon = {}
	self.temp_icon = {}
end

function faction_ui:PopupIcon_Callbacks()
	for i = 1 , 30 do
		self:AddCallback("btn_icon_" .. tostring(i), ui_events.BUTTON_CLICKED, self["OnIcon_" .. tostring(i)], self)
	end
end

function faction_ui:PopupIcon_Show (state)
	local xml = self.xml
	
	self.black_2:Show(state)
	self.dialog_2:Show(state)
	self.cap_icon:Show(state)
	self.scroll_icon:Clear()
	if state then
		self.access = false
		
		local n = 10
		local x = 20
		local w = self.tempy_icon:GetWidth()
		local h = self.tempy_icon:GetHeight()
		for i = 1 , #self.table_icon do
			self.temp_icon[i] = xml:InitStatic("main_dialog:popup_icon:temp_icon" , self.templ_icon)
			self.temp_icon[i]:InitTexture(self.table_icon[i])
			self.temp_icon[i]:SetStretchTexture(true)
			self.temp_icon[i]:SetWndSize(vector2():set(w , h))
			self.btn_icon[i] = xml:Init3tButton("main_dialog:popup_icon:btn_icon" , self.templ_icon)
			
			self.temp_icon[i]:SetWndPos(vector2():set(x, n))
			self.btn_icon[i]:SetWndPos(vector2():set(x, n))
			
			self:Register(self.temp_icon[i], "btn_icon_" .. tostring(i) )
			self:Register(self.btn_icon[i], "btn_icon_" .. tostring(i) )
			n = n + h + 10
		end
		for i = #self.table_icon + 1 , 50 do -- everything else is thrown outside
			if self.temp_icon[i] and self.btn_icon[i] then
				self.temp_icon[i]:SetWndPos(vector2():set(x + 200, 0))
				self.btn_icon[i]:SetWndPos(vector2():set(x + 200, 0))
			end
		end
		self.templ_icon:SetWndSize(vector2():set(self.templ_icon:GetWidth(), n - 2 ))
		self.scroll_icon:AddWindow(self.templ_icon, true)
		self.templ_icon:SetAutoDelete(false)
	else
		self.access = true
	end
end

function faction_ui:OnIconSelect(num)
	self.selected_icon = self.table_icon[num]
	self:UpdateIcon()
	self:PopupIcon_Show(false)
end

function faction_ui:OnIcon_1()
	self:OnIconSelect(1)
end
function faction_ui:OnIcon_2()
	self:OnIconSelect(2)
end
function faction_ui:OnIcon_3()
	self:OnIconSelect(3)
end
function faction_ui:OnIcon_4()
	self:OnIconSelect(4)
end
function faction_ui:OnIcon_5()
	self:OnIconSelect(5)
end
function faction_ui:OnIcon_6()
	self:OnIconSelect(6)
end
function faction_ui:OnIcon_7()
	self:OnIconSelect(7)
end
function faction_ui:OnIcon_8()
	self:OnIconSelect(8)
end
function faction_ui:OnIcon_9()
	self:OnIconSelect(9)
end
function faction_ui:OnIcon_10()
	self:OnIconSelect(10)
end
function faction_ui:OnIcon_11()
	self:OnIconSelect(11)
end
function faction_ui:OnIcon_12()
	self:OnIconSelect(12)
end
function faction_ui:OnIcon_13()
	self:OnIconSelect(13)
end
function faction_ui:OnIcon_14()
	self:OnIconSelect(14)
end
function faction_ui:OnIcon_15()
	self:OnIconSelect(15)
end
function faction_ui:OnIcon_16()
	self:OnIconSelect(16)
end
function faction_ui:OnIcon_17()
	self:OnIconSelect(17)
end
function faction_ui:OnIcon_18()
	self:OnIconSelect(18)
end
function faction_ui:OnIcon_19()
	self:OnIconSelect(19)
end
function faction_ui:OnIcon_20()
	self:OnIconSelect(20)
end
function faction_ui:OnIcon_21()
	self:OnIconSelect(21)
end
function faction_ui:OnIcon_22()
	self:OnIconSelect(22)
end
function faction_ui:OnIcon_23()
	self:OnIconSelect(23)
end
function faction_ui:OnIcon_24()
	self:OnIconSelect(24)
end
function faction_ui:OnIcon_25()
	self:OnIconSelect(25)
end
function faction_ui:OnIcon_26()
	self:OnIconSelect(26)
end
function faction_ui:OnIcon_27()
	self:OnIconSelect(27)
end
function faction_ui:OnIcon_28()
	self:OnIconSelect(28)
end
function faction_ui:OnIcon_29()
	self:OnIconSelect(29)
end
function faction_ui:OnIcon_30()
	self:OnIconSelect(30)
end
function faction_ui:OnIcon_31()
	self:OnIconSelect(31)
end
function faction_ui:OnIcon_32()
	self:OnIconSelect(32)
end
function faction_ui:OnIcon_33()
	self:OnIconSelect(33)
end
function faction_ui:OnIcon_34()
	self:OnIconSelect(34)
end
function faction_ui:OnIcon_35()
	self:OnIconSelect(35)
end
function faction_ui:OnIcon_36()
	self:OnIconSelect(36)
end
function faction_ui:OnIcon_37()
	self:OnIconSelect(37)
end
function faction_ui:OnIcon_38()
	self:OnIconSelect(38)
end
function faction_ui:OnIcon_39()
	self:OnIconSelect(39)
end
function faction_ui:OnIcon_40()
	self:OnIconSelect(40)
end
function faction_ui:OnIcon_41()
	self:OnIconSelect(41)
end
function faction_ui:OnIcon_42()
	self:OnIconSelect(42)
end
function faction_ui:OnIcon_43()
	self:OnIconSelect(43)
end
function faction_ui:OnIcon_44()
	self:OnIconSelect(44)
end
function faction_ui:OnIcon_45()
	self:OnIconSelect(45)
end
function faction_ui:OnIcon_46()
	self:OnIconSelect(46)
end
function faction_ui:OnIcon_47()
	self:OnIconSelect(47)
end
function faction_ui:OnIcon_48()
	self:OnIconSelect(48)
end
function faction_ui:OnIcon_49()
	self:OnIconSelect(49)
end
function faction_ui:OnIcon_50()
	self:OnIconSelect(50)
end


--=======================================< Prepare the droplists / Update the info >=======================================--
function faction_ui:LoadFaction (rand, faction)
	local pick = faction
	if (not pick) then
		pick = rand and self.table_faction[math.random(#self.table_faction)] or self.table_faction[1]
	end
	
	self.selected_faction = pick
	local money = alun_utils.read_from_ini(ini_itm, self.selected_faction .. "_money", "money", "float")
	self.selected_money = money
	
	self:UpdateFaction()
	self:UpdateMoney()
end

function faction_ui:LoadIcon (rand)
	local def_icon = "ui_inGame2_no_data"
	self.table_icon = {}
	table.insert(self.table_icon, def_icon)

	local section = self.selected_faction .. "_portraits"
	local n = ini_ico:section_exist(section) and ini_ico:line_count(section) or 0
	for i=0 , n-1 do
		local result, id, value = ini_ico:r_line(section,i,"","" )
		if (id ~= "") then
			table.insert(self.table_icon, id)
		end
	end
	
	local pick = rand and self.table_icon[math.random(#self.table_icon)] or def_icon
	
	self.selected_icon = pick
	self:UpdateIcon()
end

function faction_ui:LoadMap (rand)
	self.table_map = {}
	
	local n = ini_map:line_count(self.selected_faction .. "_start_locations") or 0
	for i=0, n-1 do
		local result, id, value = ini_map:r_line(self.selected_faction.."_start_locations",i,"","" )
		table.insert(self.table_map, id)
	end
	
	self.list_map:ClearList()
	for i=1,#self.table_map do
		self.list_map:AddItem(gs("ui_st_"..self.table_map[i]), i)
	end
	local pick = rand and self.table_map[math.random(#self.table_map)] or self.table_map[1]
	self.list_map:SetText(gs("ui_st_".. pick))
	
	self.selected_map = pick
	self:UpdateMap()
end

function faction_ui:LoadLoadout (rand)
	
	-- Reset
	self:ClearItem()
	self.points_used = 0
	self.points_left = ini_itm:r_float_ex("points","total_points") or 1000
	self.text_points_used:SetText(tostring(self.points_used))
	self.text_points_left:SetText(tostring(self.points_left))
	
	local delet = {}
	for index = 0, self.list_loadout:GetSize()-1 do
		local item = self.list_loadout:GetItemByIndex(index)
		delet[#delet+1] = item
	end
	for i = 1, #delet do
		self.list_loadout:RemoveItem(delet[i])
	end
	
	delet = {}
	for index = 0, self.list_inv:GetSize()-1 do
		local item = self.list_inv:GetItemByIndex(index)
		delet[#delet+1] = item
	end
	for i = 1, #delet do
		self.list_inv:RemoveItem(delet[i])
	end

	-- Read
	self.table_inv = {}
	self.table_loadout = {}
	local n = ini_itm:line_count(self.selected_faction .. "_loadout") or 0
	for i=0, n-1 do
		local result, id, value = ini_itm:r_line(self.selected_faction .. "_loadout" , i , "", "")
		if ini:section_exist(id) then
			local t = alun_utils.str_explode(value,",")
			if (t[1] == "false") then
				for i=1,tonumber(t[2]) do
					self.table_inv[#self.table_inv + 1] = { ["name"] = id , ["points"] = 0 }
				end
			elseif (t[1] == "true") then
				for i=1,tonumber(t[2]) do
					self.table_loadout[#self.table_loadout + 1] = { ["name"] = id ,  ["points"] = tonumber(t[3]) }
				end
			end
		end
	end
	
	-- Update
	for i = 1, #self.table_inv do
		local _itm = set_list_text( i , self.table_inv[i].name , self.table_inv[i].points , false )
		self.list_inv:AddExistingItem(_itm)
	end
	for i = 1, #self.table_loadout do
		local _itm = set_list_text( i , self.table_loadout[i].name , self.table_loadout[i].points , true )
		self.list_loadout:AddExistingItem(_itm)
	end
	
	-- Pick randomly
	if (not rand) then
		return
	end
	
	local indx_tbl, pick_tbl = {},{}
	for i = 1 , self.list_loadout:GetSize() do	
		indx_tbl[i] = i - 1
	end
		
	while (#indx_tbl > 1) do
		local j = math.random(#indx_tbl)
		local k = indx_tbl[j]
		table.remove(indx_tbl, j)
		pick_tbl[#pick_tbl + 1] = k
	end
	
	if (#pick_tbl < 1) then return end
	
	for i = 1, #pick_tbl do
		local _item = self.list_loadout:GetItemByIndex(pick_tbl[i])
		self:OnLoadoutDbClicked(_item)
	end
end

function faction_ui:LoadDifficulty (rand)
	self.list_difficulty:ClearList()
	for i=1,#self.table_difficulty do
		self.list_difficulty:AddItem(gs(self.table_difficulty[i]), i)
	end
	local pick = rand and self.table_difficulty[math.random(#self.table_difficulty)] or self.table_difficulty[2]
	self.list_difficulty:SetText(gs("gd_" .. pick))
	self.selected_difficulty = pick
end

function faction_ui:LoadEconomy (rand)
	self.list_economy:ClearList()
	for i=1,#self.table_economy do
		self.list_economy:AddItem(gs(self.table_economy[i]), i)
	end
	local pick = rand and self.table_economy[math.random(#self.table_economy)] or self.table_economy[2]
	self.list_economy:SetText(gs(pick))
	self.selected_economy = pick
end

function faction_ui:LoadHardcoreLives (rand)
	local str
	self.list_hardcore_lives:ClearList()
	for i=1, #self.table_hardcore_lives do
		str = self.table_hardcore_lives[i][1] or ""
		self.list_hardcore_lives:AddItem(str .. " " .. gs(self.table_hardcore_lives[i][2]), i)
	end
	local pick = rand and self.table_hardcore_lives[math.random(#self.table_hardcore_lives)] or self.table_hardcore_lives[1]
	str = pick[1] or ""
	self.list_hardcore_lives:SetText(str .. " " .. gs(pick[2])) 
	self.selected_hardcore_lives = pick
end

function faction_ui:LoadHardcoreRegen (rand)
	local str
	self.list_hardcore_regen:ClearList()
	for i=1, #self.table_hardcore_regen do
		str = self.table_hardcore_regen[i][1] and tostring(utils.round(self.table_hardcore_regen[i][1]/24)) or ""
		self.list_hardcore_regen:AddItem(str .. " " .. gs(self.table_hardcore_regen[i][2]), i)
	end
	local pick = rand and self.table_hardcore_regen[math.random(#self.table_hardcore_regen)] or self.table_hardcore_regen[1]
	str = pick[1] and tostring(utils.round(pick[1]/24)) or ""
	self.list_hardcore_regen:SetText(str .. " " .. gs(pick[2])) 
	self.selected_hardcore_regen = pick
end

function faction_ui:LoadTimer (rand)
	local str
	self.list_timer:ClearList()
	for i=1, #self.table_timer do
		str = self.table_timer[i][1] or ""
		self.list_timer:AddItem(str .. " " .. gs(self.table_timer[i][2]), i)
	end
	local pick = rand and self.table_timer[math.random(#self.table_timer)] or self.table_timer[1]
	str = pick[1] or ""
	self.list_timer:SetText(str .. " " .. gs(pick[2]))
	self.selected_timer = pick
end


--=======================================< GUI Callbacks >=======================================-
function faction_ui:OnFactionClicked()
	if (not self.access) then
		return
	end
	
	self:PopupFaction_Show(true)
end

function faction_ui:OnIconClicked()
	if (not self.access) then
		return
	end
	
	self:PopupIcon_Show(true)
end

function faction_ui:OnSelectMap()
	self.selected_map = self.table_map[self.list_map:CurrentID()]
	self:UpdateMap()
end

function faction_ui:OnInventoryClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_inv:GetSelectedItem()
	if not (item) then 
		return
	end
	self:UpdateItem(item)
end

function faction_ui:OnInventoryDbClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_inv:GetSelectedItem()
	if not (item) then 
		return 
	end
	
	if not (item.allow) then
		return
	end
	
	local points = item.points
	self.points_used = self.points_used - points
	self.points_left = self.points_left + points
	
	self.text_points_used:SetText(tostring(self.points_used))
	self.text_points_left:SetText(tostring(self.points_left))
	
	local _itm = set_list_text(item.idx, item.name, item.points, true)
	self.list_loadout:AddExistingItem(_itm)
	self.list_inv:RemoveItem(item)
	
	self:ClearItem()
end

function faction_ui:OnLoadoutClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_loadout:GetSelectedItem()
	if not (item) then 
		return
	end
	self:UpdateItem(item)
end

function faction_ui:OnLoadoutDbClicked (pick)
	if (not self.access) then
		return
	end
	
	local item = pick
	if (not item) then
		item = self.list_loadout:GetSelectedItem()
		if (not item) then
			return 
		end
	end
	
	local points = item.points
	
	if (points > self.points_left) then
		return
	end
	
	self.points_used = self.points_used + points
	self.points_left = self.points_left - points
	
	self.text_points_used:SetText(tostring(self.points_used))
	self.text_points_left:SetText(tostring(self.points_left))
	
	local _itm = set_list_text(item.idx, item.name, item.points, true)
	self.list_inv:AddExistingItem(_itm)
	self.list_loadout:RemoveItem(item)
	
	self:ClearItem()
end

function faction_ui:OnSelectDifficulty()
	self.selected_difficulty = self.table_difficulty[self.list_difficulty:CurrentID()]
end

function faction_ui:OnSelectEconomy()
	self.selected_economy = self.table_economy[self.list_economy:CurrentID()]
end

function faction_ui:OnSelectHardcoreLives()
	self.selected_hardcore_lives = self.table_hardcore_lives[self.list_hardcore_lives:CurrentID()]
end

function faction_ui:OnSelectHardcoreRegen()
	self.selected_hardcore_regen = self.table_hardcore_regen[self.list_hardcore_regen:CurrentID()]
end

function faction_ui:OnSelectTimer()	
	self.selected_timer = self.table_timer[self.list_timer:CurrentID()]
end

function faction_ui:OnCheckSetStory()
	if (not self.access) then
		return
	end
	
	self.ck_azazel_mode:SetCheck(false)
	self.ck_states["ck_azazel_mode"] = false
end

function faction_ui:OnCheckSetAzazel()
	if (not self.access) then
		return
	end
	
	self.ck_story:SetCheck(false)
	self.ck_states["ck_story"] = false
end

function faction_ui:OnCheckResetList()
	if (not self.access) then
		return
	end
	
	self:LoadLoadout()
end


--=======================================< Update visuals >=======================================--
function faction_ui:UpdateAll (rand, faction)
	self:LoadFaction(rand, faction)
	self:LoadIcon(rand)
	self:LoadMap(rand)
	
	self:UpdateMoney()
	self:UpdateDescr()

	self:LoadLoadout(rand)
end

function faction_ui:UpdateFaction()
	self.box_faction:InitTexture("ui_new_game_flair_" .. self.selected_faction)
	self.box_faction:SetStretchTexture(true)
	self.box_faction:SetWndSize(vector2():set(self.box_faction:GetWidth(),self.box_faction:GetHeight()))
end

function faction_ui:UpdateIcon()
	self.box_icon:InitTexture(self.selected_icon)
	self.box_icon:SetStretchTexture(true)
	self.box_icon:SetWndSize(vector2():set(self.box_icon:GetWidth(),self.box_icon:GetHeight()))
end

function faction_ui:UpdateMap()
	local map = alun_utils.read_from_ini(ini_map, self.selected_faction .. "_start_locations", self.selected_map, "string")
	
	--self.box_map:InitTexture("ui_new_game_map_" .. map)
	self.box_map:SetStretchTexture(true)
	self.box_map:SetWndSize(vector2():set(self.box_map:GetWidth(),self.box_map:GetHeight()))
end

function faction_ui:UpdateMoney()
	self.text_money:SetText(tostring(self.selected_money) .. " RU")
end

function faction_ui:UpdateDescr()
	local faction = self.selected_faction 
	
	-- Description and map
	local desc = "%c[0,250,250,250]" .. gs("st_mm_new_game_description")
	desc = desc .. "\\n%c[0,150,150,150]" .. gs("st_faction_" .. faction .. "_desc")
	
	self.text_descr:SetText(desc)
	self.text_descr:AdjustHeightToText()
	self.text_descr:SetWndSize(vector2():set(self.text_descr:GetWidth(),self.text_descr:GetHeight()+10))
	self.scroll_desc:Clear()
	self.scroll_desc:AddWindow(self.text_descr, true)
	self.text_descr:SetAutoDelete(false)
	
	-- Relations
	local str_stats = "%c[0,250,250,250]" .. gs("st_mm_new_game_relations") .. " \\n"
	local t = self.table_faction
	for i=1,#t do
		if not (t[i] == faction) then
			local v = relation_registry.community_relation("actor_" .. faction, t[i])
			if (v >= 1000) then
				str_stats = str_stats .. "%c[0,150,150,150] %c[0,50,175,50]" .. gs("st_faction_" .. t[i]) .. "\\n"
			elseif (v <= -1000) then
				str_stats = str_stats .. "%c[0,150,150,150] %c[0,175,50,50]" .. gs("st_faction_" .. t[i]) .. "\\n"
			else
				str_stats = str_stats .. "%c[0,150,150,150] %c[0,175,175,50]" .. gs("st_faction_" .. t[i]) .. "\\n"
			end
		end
	end
	
	self.text_relations:SetText(str_stats)
	self.text_relations:AdjustHeightToText()
end

function faction_ui:UpdateItem (item)
	if not (item) then
		return
	end

	-- description
	local desc = gs(ini:r_string_ex(item.name,"description"))
	
	self.text_item_descr:SetText(desc)
	self.text_item_descr:AdjustHeightToText()
	self.text_item_descr:SetWndSize(vector2():set(self.text_item_descr:GetWidth(),self.text_item_descr:GetHeight()))
	self.scroll_item_desc:Clear()
	self.scroll_item_desc:AddWindow(self.text_item_descr, true)
	self.text_item_descr:SetAutoDelete(false)
	
	-- name
	self.text_item_name:SetText( "%c[0,150,150,50] %c[0,150,150,150]" .. gs(ini:r_string_ex(item.name,"inv_name") or "") )
	self.text_item_points:SetText( "%c[0,100,50,200] %c[0,150,150,150]" .. gs("st_mm_new_game_points") .. ": " .. tostring(item.points) )
	if (not item.allow) then
		self.text_item_points:SetText( "%c[0,100,50,200] %c[0,150,150,150]" .. gs("st_mm_new_game_essential") )
	end
	
	-- Icon
	local ico = self:GetAxis_Item(item.name)
	self.box_item:InitTexture("ui\\ui_icon_equipment")
	self.box_item:SetTextureRect(Frect():set(ico.x1, ico.y1, ico.x2, ico.y2))
	self.box_item:SetStretchTexture(true)
	
	local pos = self.box_item_temp:GetWndPos()
	local _w = self.box_item_temp:GetWidth()
	local _h = self.box_item_temp:GetHeight()
	
	local ratio = ico.w/ico.h
	local h, w
	ico.w = ico.w * ico_size * ico_width
	ico.h = ico.h * ico_size
	
	local w_t, h_t = 0, 0
	local resize = false
	if (ico.w > _w) then -- if icon width is bigger than frame width
		w_t = ico.w - _w
		resize = true	
	end 
	if (ico.h > _h) then -- if icon height is bigger than frame height
		h_t = ico.h - _h 
		resize = true	
	end 
	
	if resize then -- resize is required
		if (w_t >= h_t) then -- if icon width is the big number (or square), use it as a base for resizing
			w = _w
			h = w / ratio
		elseif (w_t < h_t) then -- if icon width is the big number, use it as a base for resizing
			h = _h
			w = h * ratio
		end
	else -- no resize
		w = ico.w
		h = ico.h
	end
	
	offset_x = (_w - w)/2
	offset_y = (_h - h)/2
	self.box_item:SetWndSize(vector2():set(w , h))
	self.box_item:SetWndPos(vector2():set(pos.x + offset_x , pos.y + offset_y))
end

function faction_ui:ClearItem()
	self.text_item_name:SetText("")
	self.text_item_points:SetText("")
	self.scroll_item_desc:Clear()
	self.box_item:InitTexture("ui\\ui_icon_equipment")
	self.box_item:SetTextureRect(Frect():set(0, 0, 0, 0))
end

function faction_ui:GetAxis_Item (obj)
	local a = {}
		
	local inv_grid_x = ini:r_float_ex (obj,"inv_grid_x") or 0
	local inv_grid_y = ini:r_float_ex (obj,"inv_grid_y") or 0
	local inv_grid_width = ini:r_float_ex (obj,"inv_grid_width") or 0
	local inv_grid_height = ini:r_float_ex (obj,"inv_grid_height") or 0
	
	local x1 = inv_grid_x*50
	local y1 = inv_grid_y*50

	local w = inv_grid_width*50
	local h = inv_grid_height*50

	local x2 = x1 + w
	local y2 = y1 + h
	
	a.x1 = x1
	a.y1 = y1
	a.x2 = x2
	a.y2 = y2
	a.w = w
	a.h = h
	
	return a
end

function faction_ui:GetAxis_Icon (main , element , all_row , all_col , row , col)
	local _w = main:GetWidth()
	local _h = main:GetHeight()
	local _wi = element:GetWidth()
	local _hi = element:GetHeight()
	local off_x = (_w - _wi * all_col)/(all_col+1)
	local off_y = (_h - _hi * all_row)/(all_row+1)
	
	local x = (off_x * col) + (_wi * (col - 1))
	local y = (off_y * row) + (_hi * (row - 1))
	return x,y
end


--=======================================< Main Buttons >=======================================--
function faction_ui:OnQuit()
	if (not self.access) then
		return
	end
	
	self.owner:ShowDialog(true)
	self.owner:Show(true)
	if (self:IsShown()) then
		self:HideDialog()
	end
	self:Show(false)
end

function faction_ui:OnRandomize()
	if (not self.access) then
		return
	end
	
	-- Faction
	self.selected_faction  = self.table_faction[math.random(#self.table_faction)]
	
	-- Name
	local subset
	if (self.selected_faction == "army" or self.selected_faction == "dolg") then 
		subset = random_choice("private","sergeant","senior_sergeant","lieutenant","captain")
	else 
		subset = random_choice("stalker","bandit","science")
	end
	local name_cnt = ini:r_float_ex("stalker_names_"..subset,"name_cnt")
	local last_name_cnt = ini:r_float_ex("stalker_names_"..subset,"last_name_cnt")
	local first_name = gs( strformat("name_%s_%s",subset,math.random(0,name_cnt-1)) )
	local last_name = gs( strformat("lname_%s_%s",subset,math.random(0,last_name_cnt-1)) )
	self.character_name:SetText(first_name .. " " .. last_name)
	
	-- Everything else
	self:UpdateAll(true, self.selected_faction)
	
	-- Difficulty and Economy
	self:LoadDifficulty(true)
	--self:LoadEconomy(true)
end

function faction_ui:OnKeyboard(dik, keyboard_action)
	if (not self.access) then
		return
	end
	
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_ESCAPE then
				self:OnQuit()
			elseif (dik == DIK_keys.DIK_Z) then
				self.selected_faction = "zombied"
				self:UpdateAll(false , self.selected_faction)
			elseif (dik == DIK_keys.DIK_S) then
			end
		end
	end
	return res
end

function faction_ui:OnStartGame()
	if (not self.access) then
		return
	end

	-- start game anyway if no config or axr_main script
	if not (axr_main and axr_main.config) then
		self.owner:StartGame()
		return
	end
	
	-- check name
	local character_name = self.character_name:GetText()
	if (character_name == "") then
		-- Require a name to be entered.
		return
	end
	
	-- check location
	if (self.selected_map == nil or self.selected_map == "" or self.list_map:CurrentID() <= 0) then
		local index = math.random(1,#self.table_map)
		self.selected_map = self.table_map[index]
	end
	
	-- save modes
	local hardcore_regen
	if (self.selected_hardcore_regen[1]) and (type(self.selected_hardcore_regen[1]) == "number") then
		hardcore_regen = self.selected_hardcore_regen[1]
	end
	
	local timer
	if (self.selected_timer[1]) and (type(self.selected_timer[1]) == "number") then
		timer = self.selected_timer[1]
	end
	
	-- prepare loadout
	local loadout_str
	for index = 0, self.list_inv:GetSize()-1 do
		local item = self.list_inv:GetItemByIndex(index)
		if (not loadout_str) then
			loadout_str = item.name
		else
			loadout_str = loadout_str .. "," .. item.name
		end
	end
	
	-- preparing economy values
	if (self.selected_economy == nil or self.selected_economy == "") then
		self.selected_economy = self.table_economy[2]
	end
	local econ = self.selected_economy:gsub("st_","")
	local goodwill = ini_eco:r_float_ex(econ, "multi_goodwill") or axr_main.config:r_value("mm_options","multi_rewards_goodwill",2,1)
	local money = ini_eco:r_float_ex(econ, "multi_money") or axr_main.config:r_value("mm_options","multi_rewards_money",2,1)
	local wpn = ini_eco:r_float_ex(econ, "multi_wpn_condition") or axr_main.config:r_value("mm_options","multi_wpn_conditions",2,1)
	local loot = ini_eco:r_float_ex(econ, "multi_loot") or axr_main.config:r_value("mm_options","multi_loot",2,1)
	
	axr_main.config:w_value("character_creation","new_game_difficulty",self.selected_difficulty)
	axr_main.config:w_value("character_creation","new_game_economy_goodwill",utils.round(goodwill,2))
	axr_main.config:w_value("character_creation","new_game_economy_money",utils.round(money,2))
	axr_main.config:w_value("character_creation","new_game_economy_wpn",utils.round(wpn,2))
	axr_main.config:w_value("character_creation","new_game_economy_loot",utils.round(loot,2))
	
	axr_main.config:w_value("character_creation","new_game_hardcore_mode",self.ck_hardcore and self.ck_hardcore:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_hardcore_mode_lives",self.ck_hardcore and self.selected_hardcore_lives[1] or nil)
	axr_main.config:w_value("character_creation","new_game_hardcore_mode_regenerate",self.ck_hardcore and hardcore_regen or nil)
	axr_main.config:w_value("character_creation","new_game_story_mode",self.ck_story and self.ck_story:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_azazel_mode",self.ck_azazel_mode and self.ck_azazel_mode:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_survival_mode",self.ck_survival and self.ck_survival:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_campfire_mode",self.ck_campfire and self.ck_campfire:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_conditions_mode",self.ck_conditions and self.ck_conditions:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_timer_mode",timer or nil)
	
	axr_main.config:w_value("character_creation","new_game_character_name",character_name:gsub(" ","_") )
	axr_main.config:w_value("character_creation","new_game_faction",self.selected_faction or nil)
	axr_main.config:w_value("character_creation","new_game_icon",self.selected_icon or nil)
	axr_main.config:w_value("character_creation","new_game_loadout",loadout_str or nil)
	axr_main.config:w_value("character_creation","new_game_map",self.selected_map or nil)
	axr_main.config:w_value("character_creation","new_game_money",self.selected_money or nil)
	
	axr_main.config:save() -- Store info in temp file
	self.owner:StartGame() -- Start the game
end


--=======================================< List Item  >=======================================--
class "set_list_text" (CUIListBoxItem)
function set_list_text:__init(idx, name, points, allow) super(idx, name, points, allow)
	
	self.idx					= idx
	self.points					= points
	self.allow					= allow
	self.name					= name
	self.string 				= name
	self.text					= self:GetTextItem()
	self.text:SetWndRect		(Frect():set(0,0,300,22))
	self:SetTextColor			(GetARGB(255, 130, 128, 120))
	self.text:SetFont			(GetFontLetterica16Russian())
	self.text:SetWndSize		(vector2():set(400,22))
	self.text:SetEllipsis		(true)
	self.text:SetText			(gs (ini:r_string_ex (self.string,"inv_name") or ""))
	
end

