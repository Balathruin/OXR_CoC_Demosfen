local cmd = {}

function command_get_list()
	return cmd
end

function command_get_count()
	return table.size(cmd)
end

function command_exists(name)
	return cmd[name] ~= nil
end

function command_give(name,...)
	return cmd[name](name,...)
end


local function trim(s)
	return string.gsub(s, "^%s*(.-)%s*$", "%1")
end

local function first_word(txt)
	local _strt, _end = string.find(txt,".%S+")
	if (_strt and _end) then
		return trim(string.lower(string.sub(txt,_strt, _end))),trim(string.sub(txt,_end+1))
	end
	return "",""
end 

function check_and_set_help(caller,txt,owner,msg)
	local wrd,rest = first_word(txt)
	
	if (wrd == "") then 
		owner:SendOutput("For usage type %s help",caller)
		return
	end 
	
	if (string.find(wrd,"help")) then
		owner:SendOutput("%s %s",caller,msg)
		return
	end
	return wrd,rest
end 

function cmd.sandbox(me,txt,owner,p)
	if txt and not (txt == '') then
		local function start()
			dofile(getFS():update_path('$game_scripts$', txt..'.lua'))
		end
		local condition, err = pcall(start)
		printf(condition and '--Succesfull '..txt..'.lua execution!' or '! '..err)
		get_console():execute('flush')
	end
end

-- HELP
function cmd.help(me,txt,owner,p)
	local wrd,rest = first_word(txt)
	local page = tonumber(txt) or 1
	local sz = owner.console_size

	if not (sz) or (sz == 0) then return "help := error" end

	local a = {}
    for n in pairs(cmd) do
		if (n ~= "help") then
			table.insert(a, n)
		end
	end
    table.sort(a)
	
	local page_count = math.ceil(#a/sz)
	if (page > page_count) then
		return "help:= Invaild page"
	end
	
	owner:SendOutput("help := Command List [%s of %s]",page,page_count)
	owner:SendOutputList(a,(page*sz)-sz,sz-1)
end

-- ECHO
function cmd.echo(me,txt,owner,p)
	return txt
end

function cmd.char_desc(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[checkall]")
	if not (wrd) then return end
	if not (wrd == "checkall") then return "char_desc:= try char_desc checkall" end
	
	local f = {	"character_desc_agroprom",
				"character_desc_bar",
				"character_desc_darkvalley",
				"character_desc_deadcity",
				"character_desc_escape",
				"character_desc_general",
				"character_desc_jupiter",
				"character_desc_katacomb",
				"character_desc_marsh",
				"character_desc_military",
				"character_desc_pripyat",
				"character_desc_red_forest",
				"character_desc_simulation",
				"character_desc_underpass",
				"character_desc_yantar",
				"character_desc_zaton"
			}
			
	local tags = {			["name"] = false,
							["icon"] = false,
							["map_icon"] = false,
							--["bio"] = false,
							["class"] = false,
							["community"] = false,
							["terrain_sect"] = false,
							["money"] = false,
							["rank"] = false,
							["reputation"] = false,
							["visual"] = false,
							--["snd_config"] = false,
							["supplies"] = false,
							--["actor_dialog"] = false
	}
	
	local xml,node,id,char_node,p
	for i=1,#f do 
		xml = alun_utils.XmlParser:loadFile(getFS():update_path('$game_config$', '').."gameplay\\"..f[i]..".xml")
		if (xml) then
			for index,node in pairs(xml.ChildNodes) do
				if (type(node) == "table") then

					-- Check if all specific_character nodes for mandatory child nodes
					for k,child in pairs(node.ChildNodes) do
						if (type(child) == "table") then
							if (tags[child.Name] == false) then 
								tags[child.Name] = true
							end
						end
					end	

					-- Validate that all nodes by tag names exist
					for k,v in pairs(tags) do 
						if (v == false) then 
							owner:SendOutput("char_desc:= specific character id=%s missing a mandatory node by name %s",node.Attributes.id,k)
						end
						-- reset for next loop
						tags[k] = false
					end
					
				end
			end
		else
			owner:SendOutput("char_desc:= no xml by name %s",f[i])
		end 
	end
	return "char_desc:= scanning complete"
end 

-- print
function cmd.print(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[_G]")
	if not (wrd) then return end
	
	if (wrd == "_G" or wrd == "_g") then 
		local list = { f={}, t={}, u={}, b={}, n={}, s={}, unknown={} }
		
		local msg = ""
		for k,v in pairs(_G) do 
			if (type(v) == "userdata") then 
				table.insert(list.u,k)
			elseif (type(v) == "function") then 
				table.insert(list.f,k)
			elseif (type(v) == "boolean") then 
				table.insert(list.b,k)
			elseif (type(v) == "number") then 
				table.insert(list.n,k)
			elseif (type(v) == "string") then 
				table.insert(list.s,k)
			elseif (type(v) == "table") then 
				table.insert(list.t,k)
			else 
				table.insert(list.unknown,k)
			end
		end
		
		for k,v in pairs(list) do 
			table.sort(v)
		end
		
		msg = msg .. "\n\nNUMBER" .. "\n"
		for i=1,#list.n do
			msg = msg .. list.n[i] .. " = " .. tostring(_G[list.n[i]]) .. "\n"
		end
		
		msg = msg .. "\n\nBOOLEAN" .. "\n"
		for i=1,#list.b do
			msg = msg .. list.b[i] .. " = " .. tostring(_G[list.b[i]]) .. "\n"
		end		
		
		msg = msg .. "\n\nSTRING" .. "\n"
		for i=1,#list.s do
			msg = msg .. list.s[i] .. " = " .. _G[list.s[i]] .. "\n"
		end
		
		msg = msg .. "\n\nTABLE" .. "\n"
		for i=1,#list.t do
			msg = msg .. list.t[i] .. "\n"
		end
	
		msg = msg .. "\n\nFUNCTION" .. "\n"
		for i=1,#list.f do
			msg = msg .. list.f[i] .. "\n"
		end
		
		msg = msg .. "\n\nUSERDATA" .. "\n"
		for i=1,#list.u do
			msg = msg .. list.u[i] .. "\n"
		end
		
		msg = msg .. "\n\nUNKNOWN" .. "\n"
		for i=1,#list.unknown do
			msg = msg .. list.unknown[i] .. "\n"
		end
		
		local file = io.open("debug_print.txt","w")
		file:write(msg)
		file:close()
		return "print:= output sent to debug_print.txt"
	end 
	
	return "print:= incorrect subcommands. Type 'print help'"
end 

-- reload_system_ini
function cmd.reload_system_ini(me,txt,owner,p)
	if (reload_system_ini) then 
		reload_system_ini()
		return "reload_system_ini:= success"
	end
	return "reload_system_ini:= failure, engine does not have this function!"
end

-- Relations
function cmd.relations(me,txt,owner,p)
	owner:SendOutput("Stalker = %s",relation_registry.community_goodwill("stalker", 0))
	owner:SendOutput("Bandit = %s",relation_registry.community_goodwill("bandit", 0))
	owner:SendOutput("Renegade = %s",relation_registry.community_goodwill("renegade", 0))
	owner:SendOutput("Mercenary = %s",relation_registry.community_goodwill("killer", 0))
	owner:SendOutput("CSky = %s",relation_registry.community_goodwill("csky", 0))
	owner:SendOutput("Freedom = %s",relation_registry.community_goodwill("freedom", 0))
	owner:SendOutput("Duty = %s",relation_registry.community_goodwill("dolg", 0))
	owner:SendOutput("Army = %s",relation_registry.community_goodwill("army", 0))
	owner:SendOutput("Monolith = %s",relation_registry.community_goodwill("monolith", 0))
	owner:SendOutput("Ecolog = %s",relation_registry.community_goodwill("ecolog", 0))
	return "relations:= command finished"
end 

-- Lua Count All
function cmd.lua_countall(me,txt,owner,p)
	local seen = {}
	local function count_all(f)
		local function count_table(t)
			if seen[t] then return end
			f(t)
			seen[t] = true
			for k,v in pairs(t) do
				if type(v) == "table" then
					count_table(v)
				else
					f(v)
				end
			end
		end
		count_table(_G)
	end

	local count = 0
	local function track(o)
		if (type(o) == "function") then 
			count = count + 1
		end
	end
	
	count_all(track)
	
	output = strformat("%s functions. %s bytes used",count,count*20)
	
	return "lua_countall:= " .. output
end 

-- Community
function cmd.community(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<community>")
	if not (wrd) then return end
	
	local comm_list = alun_utils.get_communities_list()
	for comm,v in pairs(comm_list) do 
		if (wrd == comm) then 
			db.actor:set_character_community(wrd, 0, 0)
			return "community:= actor community changed to "..wrd
		end
	end
	return "community:= invalid community"
end

-- Name
function cmd.name(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<name>")
	if (wrd) then
		local se_actor = alife():actor()
		wrd = wrd:gsub("(%l)(%w*)", function(a,b) return string.upper(a)..b end)
		wrd = wrd:gsub("_", " ")
		se_actor:set_character_name(wrd)
		return "name:= actor name changed to "..wrd
	end
	
	return "name:= invalid name"
end

-- Rank
function cmd.rank(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<amount>")
	if not (wrd) then return end
	local amt = tonumber(wrd) or 0
	dxr_statistics.increment_rank(amt)
	return "rank:= gave actor "..amt.." rank points."
end

-- Reputation
function cmd.reputation(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<amount>")
	if not (wrd) then return end
	local amt = tonumber(wrd) or 0
	dxr_statistics.increment_reputation(amt)
	return "reputation:= gave actor "..amt.." reputation points."
end

-- Statistic
function cmd.statistic(me,txt,owner,p)
	local wrd, rest = check_and_set_help(me,txt,owner,"<name> <amount>")
	if not (wrd and rest) then return end
	local amt = tonumber(rest) or 0
	for i = 1, amt do
		dxr_statistics.increment_statistic(wrd)
	end
	return "statistic:= incremented "..wrd.." by " .. amt .. "."
end

-- Guide
function cmd.guide(me,txt,owner,p)
	local wrd, rest = check_and_set_help(me,txt,owner,"[unlockall | unlock <article>]")
	-- unlock all articles
	if (wrd and wrd == "unlockall") then
		local count = dxr_encyclopedia.get_articles_locked_count()
		for i=1, count do
			dxr_encyclopedia.unlock_article()
		end
		return "guide:= unlocked all articles"
	end
	-- unlock a specific article
	if (wrd and wrd == "unlock") then
		if (rest) then
			dxr_encyclopedia.unlock_article(rest)
			return "guide:= unlocked " .. rest
		end
	end
	return
end

-- SPAWN
--[[
example usage:

spawn s:stalker id:%s amt:5 $db.actor:id()     -- Spawns 5 stalkers at actor's position

spawn s:wpn_pm id:5424 						   -- Spawns Pistol on ID's position

spawn s:wpn_pm id:$db.actor:id()$

spawn s:wpn_pm pos:244,355,123 lvid:11344 gvid:12  -- Spawns pistol at exact location

--]]
function cmd.spawn(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"s:<section> id:<number> amt:<number> [ pos:<x,y,z> lvid:<x,y,z> gvid:<x,y,z> ]")
	if not (wrd) then return end

	if (wrd == "reset") then
		owner.spawn_pos = nil
		owner.spawn_lvid = nil
		owner.spawn_gvid = nil
		return "spawn:= position reset to always actor"
	end

	if (wrd == "items") then
		if not (system_ini():section_exist("inv_backpack")) then
			return "spawn:= requires inv_backpack from items_minimod"
		end
		local sim = alife()
		local stash = sim:create("inv_backpack",db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
		local itm
		if not (se_item.registered_items) then 
			return "spawn:= registered items table needs uncommented in se_item.script"
		end
		for k,v in pairs(se_item.registered_items) do
			sim:create(k,stash.position,0,0,stash.id)
		end
		return "spawn:= all registered items in game spawned in a stash near you"
	end

	local sec
	if (string.find(txt,"s:")) then
		for s in string.gmatch(txt,"s:(.%S+)") do
			sec = s
		end
	end

	if not (sec) or not (system_ini():section_exist(sec)) then
		return "spawn:= Section %s does not exist.",sec
	end

	local pos,lvid,gvid,id

	if (string.find(txt,"id:")) then
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end

		local obj = level.object_by_id(id)
		if (obj) then
			pos = obj:position()
			lvid = obj:level_vertex_id()
			gvid = obj:game_vertex_id()
		end
	else
		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
				local p = alun_utils.str_explode(s,",")
				pos = vector():set(tonumber(p[1]),tonumber(p[2]),tonumber(p[3]))
			end

			if (string.find(txt,"lvid:")) then
				for s in string.gmatch(txt,"lvid:(%w+)") do
					lvid = tonumber(s)
				end
			else
				return "spawn:= Must specify level_vertex_id along with position."
			end

			if (string.find(txt,"gvid:")) then
				for s in string.gmatch(txt,"gvid:(%w+)") do
					gvid = tonumber(s)
				end
			else
				return "spawn:= Must specify game_vertex_id along with position."
			end
		else
			return "spawn:= Must specify id or position. Type spawn help"
		end
	end

	local amt = 1
	if (string.find(txt,"amt:")) then
		for s in string.gmatch(txt,"amt:(%d+)") do
			amt = tonumber(s)
		end
	end

	if (pos) and (lvid) and (gvid) then
		for i=1,amt do
			local obj = alife():create(sec,pos,lvid,gvid,id)
		end

		if (amt > 1) then
			return "Spawn:= Objects created"
		end

		if not (obj) then
			return "spawn:= Object nil"
		end
		return "spawn:= Object %s created as ID %s.",obj:name(),obj.id
	end

	local p = string.format("%0.2f,%0.2f,%0.2f",pos.x,pos.y,pos.z)
	return "spawn:= Error pos=%s lvid=%s gvid=%s",p,lvid,gvid
end

-- collectgarbage
function cmd.collectgarbage(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[full|count|step]")
	if not (wrd) then return end

	if (wrd == "full") then
		local before = collectgarbage("count")
		collectgarbage()
		collectgarbage()
		local after = collectgarbage("count")
		return "collectgarbage:= |before|=>"..before.." |after|=> "..after
	elseif (wrd == "count") then
		local count = collectgarbage("count")
		return "collectgarbage:= "..count
	elseif (wrd == "step") then
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
			local amt = wrd and wrd ~= "" and tonumber(wrd) or 0
			if (amt) then
				xrs_debug_tools.STEP = amt
			end
		end
	else
		return "collectgarbage:= wrong argument passed."
	end
end

function cmd.attach(me,txt,owner,p)
	local wpn = db.actor:active_item()
	if (wpn) then
		local firearm = IsWeapon(wpn)
		if (firearm) then
			if (wpn.weapon_addon_attach) then
				local addons = {
					"wpn_addon_scope",
					"wpn_addon_scope_x2.7",
					"wpn_addon_scope_detector",
					"wpn_addon_scope_night",
					"wpn_addon_scope_susat",
					"wpn_addon_scope_susat_x1.6",
					"wpn_addon_scope_susat_custom",
					"wpn_addon_scope_susat_dusk",
					"wpn_addon_scope_susat_night",
					"wpn_addon_silencer",
					"wpn_addon_pistol_suppressor",
					"wpn_addon_rifle_suppressor",
					"wpn_addon_grenade_launcher",
					"wpn_addon_grenade_launcher_m203"
					}
				local addon
				local attached = false
				for k,v in pairs(addons) do
					addon = db.actor:object(k)
					if (addon) then 
						wpn:weapon_addon_attach(addon)
						attached = true
					end
				end 
				
				if (attached) then 
					return "attach:= addon attached"
				end 
				return "attach:= no addons attached"
			else 
				return "attach:= weapon does not have weapon_addon_attach method"
			end
		end 
	end
	return "attach:= addon was not attached for active weapon"
end 

function cmd.detach(me,txt,owner,p)
	local wpn = db.actor:active_item()
	if (wpn) then
		local firearm = IsWeapon(wpn)
		if (firearm and wpn.weapon_addon_detach) then
			local addons = {
				"wpn_addon_scope",
				"wpn_addon_scope_x2.7",
				"wpn_addon_scope_detector",
				"wpn_addon_scope_night",
				"wpn_addon_scope_susat",
				"wpn_addon_scope_susat_x1.6",
				"wpn_addon_scope_susat_custom",
				"wpn_addon_scope_susat_dusk",
				"wpn_addon_scope_susat_night",
				"wpn_addon_silencer",
				"wpn_addon_pistol_suppressor",
				"wpn_addon_rifle_suppressor",
				"wpn_addon_grenade_launcher",
				"wpn_addon_grenade_launcher_m203"
				}
			local addon
			for k,v in pairs(addons) do
				wpn:weapon_addon_detach(k)
			end 

			return "detach:= check item"
		end 
	end
	return "detach:= addon was not detached from active weapon"
end 

local function parse_waypoint(pathname, wpflags, wpname, owner, tRet)

	local rslt = {}

	rslt.flags = wpflags

	local at
	if string.find(wpname, "|", at, true) == nil then
		return rslt
	end

	--[[
	file = io.open("axr_debug_log.txt","a+")
	if (file) then
		file:write(strformat("[%s] %s", pathname, wpname).."\n")
		file:close()
	end
	--]]

	local par_num
	local fld
	local val

	par_num = 1
	for param in string.gmatch(wpname, "([%w%+~_\\%=%{%}%s%!%-%,%*]+)|*") do
		if par_num == 1 then
			-- continue
		else
			if param == "" then
				owner:SendOutput("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
				printf("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
			else
				local t_pos = string.find(param, "=", 1, true)
				if (t_pos) then
					fld = string.sub(param, 1,t_pos - 1)
					if not (fld and fld ~= "") then
						tRet[#tRet+1] = strformat("path '%s': waypoint '%s': syntax error while parsing the param '%s': no field specified",pathname, wpname, param)
						printf("path '%s': waypoint '%s': syntax error while parsing the param '%s': no field specified",pathname, wpname, param)
					else
						val = string.sub(param, t_pos + 1)
						if not (val and val ~= "") then
							val = "true"
						end

						if fld == "a" then
							rslt[fld] = xr_logic.parse_condlist(db.actor, "waypoint_data", "anim_state", val)

							if not (state_lib.states[val]) then
								tRet[#tRet+1] = strformat("path '%s': waypoint '%s': not a valid state_lib anim  %s", pathname, wpname,val)
								printf("path '%s': waypoint '%s': not a valid state_lib anim %s", pathname, wpname,val)
							end
						else
							rslt[fld] = val
						end
					end
				else
					tRet[#tRet+1] = strformat("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
					printf("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
				end
			end
		end
		par_num = par_num + 1
	end
	return rslt
end

function cmd.waypoint(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[checkall | checklevel | checkindex]")
	if not (wrd) then return end

	if not (wrd == "checkall" or wrd == "checklevel" or wrd == "checkindex") then
		return "waypoint:= invalid argument. Type waypoint help for a list of subcommands"
	end

	local npc = xrs_debug_tools.get_debug_npc()
	if (npc == nil and wrd == "checklevel" and npc:id() ~= 0) then
		return "waypoint:= need NPC to validate waypoints, no nearest stalker found."
	end

	local path_jobs = {"surge","collector","walker","patrol","guard","sniper","camper","sleep"}

	local smart,gname,name,ptr,cnt,i,vec
	local b = {}
	local last_index

	local sim = alife()
	local actor_level = wrd == "checklevel" and sim:level_name(game_graph():vertex(sim:actor().m_game_vertex_id):level_id()) or "nil"

	local checked = false
	local gg = game_graph()
	
	local t = {}
	for id, smart in sim:objects() do
		if (smart and smart:clsid() == clsid.smart_terrain) then
			gname = smart:name()
			if (wrd == "checkindex") then
				checked = true
				for index,job in ipairs(path_jobs) do
					b=empty_table(b)
					last_index = 0
					for add=1,20 do
						name = job == "sleep" and gname.."_"..job.."_"..add or gname.."_"..job.."_"..add.."_walk"
						ptr = patrol(name)
						if (ptr) then
							b[add] = name
							last_index = add
						end						
					end
					for add=1,last_index do 
						if b[add] == nil then 
							t[#t+1] = strformat("path %s does not exist!",job == "sleep" and gname.."_"..job.."_"..add or gname.."_"..job.."_"..add.."_walk")
						end
					end
				end			
			elseif (wrd == "checkall" or self.is_on_actor_level) then	
				for index,job in ipairs(path_jobs) do
					i = 1
					while level.patrol_path_exists(job == "sleep" and gname.."_"..job.."_"..i or gname.."_"..job.."_"..i.."_walk") do
						name = job == "sleep" and gname.."_"..job.."_"..i or gname.."_"..job.."_"..i.."_walk"
						ptr = patrol(name)
						if (ptr) then
							checked = true
							cnt = ptr:count()
							for n=0,cnt-1 do
							
								if not (gg:valid_vertex_id(ptr:game_vertex_id(n))) then
									t[#t+1] = strformat("path %s p%s:%s does not have valid game_vertex_id",name,n,ptr:name(n))
									printf("path %s p%s:%s does not have valid game_vertex_id",name,n,ptr:name(n))
								end
								
								if (actor_level ~= "nil") then 
									if not (alun_utils.accessible(npc,ptr:level_vertex_id(n))) then
										t[#t+1] = strformat("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
										printf("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
									end
								else 
									if (ptr:level_vertex_id(n) >= 4294967295) then 
										t[#t+1] = strformat("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
										printf("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
									end
								end
								parse_waypoint(name,ptr:flags(n),ptr:name(n),owner,t)
							end
						end
						-- Validate look waypoint also
						name = gname.."_"..job.."_"..i.."_look"
						if (level.patrol_path_exists(name)) then 
							ptr = patrol(name)
							if (ptr) then 
								checked = true
								cnt = ptr:count()
								for n=0,cnt-1 do
									parse_waypoint(name,ptr:flags(n),ptr:name(n),owner,t)
								end
							end
						end
						i = i + 1
					end
				end
			end
		end
	end

	if (checked) then
		if (#t > 0) then
			wrd = ""
			local _strt, _end = string.find(txt,"%d+")
			if (_strt and _end) then
				wrd = string.sub(txt,_strt, _end)
				wrd = string.lower(wrd)
			end

			local page = wrd ~= "" and tonumber(wrd) or 1

			local sz = owner.console_size

			if not (sz) or (sz == 0) then return "waypoint:= error" end

			local page_count = math.ceil(#t/sz)

			if (page > page_count) then
				return "waypoint:= Invalid page"
			end

			table.sort(t)

			owner:SendOutput("waypoint:= Bad Waypoints [%s of %s]",page,page_count)
			owner:SendOutputList(t,(page*sz)-sz,sz-1)
			return
		end
		return "waypoint: successfully checked all gulag job paths."
	end 
	return "waypoint: failed, no checking done."
end



-- SURGE
function cmd.surge(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[start|stop]")
	if not (wrd) then return end

	local sm = surge_manager.SurgeManager
	if not (sm) then return "No surge manager!" end

	if (wrd == "start") then
		sm:start(true)
		return "surge:= started"
	elseif (wrd == "stop") then
		sm:end_surge(true)
		return "surge:= ended"
	else
		return "surge:= wrong argument passed."
	end
end

-- PsiStorm
function cmd.psi_storm(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[start|stop]")
	if not (wrd) then return end

	local sm = psi_storm_manager and psi_storm_manager.PsiStormManager
	if not (sm) then return "No psi_storm manager!" end

	if (wrd == "start") then
		sm:start(true)
		return "psi_storm:= started"
	elseif (wrd == "stop") then
		sm:finish(true)
		return "psi_storm:= ended"
	else
		return "psi_storm:= wrong argument passed."
	end
end


-- Fallout
function cmd.fallout(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[start|stop]")
	if not (wrd) then return end

	local sm = fallout_manager and fallout_manager.get_fallout_manager()
	if not (sm) then return "No fallout manager!" end

	if (wrd == "start") then
		sm:start(true)
		return "fallout:= started"
	elseif (wrd == "stop") then
		sm:end_surge(true)
		return "fallout:= ended"
	else
		return "fallout:= wrong argument passed."
	end
end


-- Find
function cmd.find(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<name>")
	if not (wrd) then return end

	if (p[1]) then
		owner:FindNearest(p[1])
	else
		owner:FindNearest(wrd)
	end
end

-- Execute
function cmd.execute(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<string>")
	if not (wrd) then return end

	local f,err = assert(loadstring(wrd))
	if (f) then
		f()
	else
		return err
	end
end

-- Alife

function cmd.alife(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{switch}")
	if not (wrd) then return end

	if (string.find(wrd,"switch")) then
		--[[
		if (string.find(txt,"set:")) then
			local d
			for s in string.gmatch(txt,"set:(%d+)") do
				d = tonumber(s)
			end
			if not (d) then
				return "alife := Invalid value for switch distance set:%s",d
			end
			local old = alife():switch_distance()
			alife():switch_distance(d)
			return "alife := switch distance changed from %s to %s",old,d
		elseif (string.find(txt,"get")) then
			local sd = alife():switch_distance()
			return "alife := switch distance is %s",sd
		else
			return "alife switch [get|set:<value>]"
		end
		--]]
		local sd = alife():switch_distance()
		return "alife:= switch distance is %s",sd
	end
end

-- Clear
function cmd.clear(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"(Clears console)")
	if (string.find(txt,"help")) then
		return
	end

	for i=1,owner.console_size do
		owner.txt_console[i]:SetText("")
	end
end

-- Squad
function cmd.squad(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[teleport <id:number target:number> | assign <id:number target:number> | remove_sim")
	if not (wrd) then return end

	if (string.find(wrd,"teleport")) then 
		local id,squad,a_id,target
		if (string.find(txt,"id:")) then
			for s in string.gmatch(txt,"id:(%d+)") do
				id = tonumber(s)
			end

			squad = alife_object(id)
			if not (squad) then
				return "squad:= improper id used. id:%s",id
			end
		end
		
		if (string.find(txt,"target:")) then
			for s in string.gmatch(txt,"target:(%d+)") do
				a_id = tonumber(s)
			end

			target = alife_object(a_id)
			if not (target) then
				return "squad:= target by id %s does not exist.",a_id
			end
		end

		if (squad and target) then
			TeleportSquad(squad,target.position,target.m_level_vertex_id,target.m_game_vertex_id)
			return "squad := %s teleported to %s.",squad:name(),target:name()
		end
	elseif (string.find(wrd,"assign")) then
		local id,squad,a_id,target
		if (string.find(txt,"id:")) then
			for s in string.gmatch(txt,"id:(%d+)") do
				id = tonumber(s)
			end

			squad = alife_object(id)
			if not (squad) then
				return "squad:= improper id used. id:%s",id
			end
		end

		if (string.find(txt,"target:")) then
			for s in string.gmatch(txt,"target:(%d+)") do
				a_id = tonumber(s)
			end

			target = alife_object(a_id)
			if not (target) then
				return "squad:= assign target does not exist. assign:%s",a_id
			end
		end

		if (squad and target) then
			alun_utils.assign_squad_to_smart(squad.id,target.id)
			return "squad := %s assigned to %s.",squad:name(),target:name()
		end
	elseif (wrd == "remove_sim") then
		local sim = alife()
		for id, squad in sim:objects() do
			if (story_objects.story_id_by_object_id[id] == nil) then
				if (squad:clsid() == clsid.online_offline_group_s) then 
					squad:remove_squad()
				end
			end
		end
		return "squad:= removed all simulation squads"
	end

	return "squad:= squad assign id:<id> target:<id>"
end

-- Console
function cmd.console(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{relay}")
	if not (wrd) then return end

	if (string.find(wrd,"relay")) then
		if (owner.console_relay) then
			owner.console_relay = false
			return "Toggled off relay to game console"
		else
			owner.console_relay = true
		end
		return "Toggled on relay to game console"
	end
end

-- Teleport
function cmd.teleport(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"who:<id> [ to:<id> | pos:<x,y,z> | $code$ | cam ]")
	if not (wrd) then return end

	local who,to_pos,to_obj

	if (string.find(txt,"who:")) then
		local who_id
		for s in string.gmatch(txt,"who:(%w+)") do
			who_id = tonumber(s)
		end

		who = who_id and alife_object(who_id)
		if not (who) then
			return "teleport := Wrong argument given or object doesn't exist. who:<%s>",who_id
		end
	end

	if (string.find(txt,"to:")) then
		local id
		for s in string.gmatch(txt,"to:(%w+)") do
			id = tonumber(s)
		end

		to_obj = id and alife_object(id)
		if not (to_obj) then
			return "teleport := Wrong arugment given or object doesn't exist. id:%s",id
		end

		to_pos = to_obj.position
	else
		local pos = p[1]

		if (string.find(txt,"cam")) then
			pos = xrs_debug_tools.LastCameraPos
		end

		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
				local t = alun_utils.str_explode(s,",")
				pos = vector():set(tonumber(t[1]),tonumber(t[2]),tonumber(t[3]))
			end
		end

		if not (pos) then
			return "teleport := wrong format for position. pos:%s must be pos:x,y,z"
		end

		to_pos = pos
	end
	
	
	if (who and to_pos) then
		local success = false
		if (who.id == 0) then 
			db.actor:set_actor_position(to_pos)
			success = true
		elseif (to_obj) then
			local squad
			if (IsStalker(who) or IsMonster(who)) then 
				local object = level.object_by_id(who.id)
				if (object) then
					object:set_npc_position(to_pos)
					success = true
				else 
					squad = get_object_squad(who)
				end
			elseif (who:clsid() == clsid.online_offline_group_s) then 
				squad = who
			end 
			
			if (squad and alife().teleport_object) then 
				TeleportSquad(squad,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
				success = true
			end
		end
		
		if (success) then 
			local pos = string.format("%0.3f, %0.3f, %0.3f",to_pos.x,to_pos.y,to_pos.z)
			return "teleport:= %s teleported to pos:%s",who:name(),pos
		end
	end
	
	return "teleport:= failed to teleport %s",who and who:name()
end

-- Wound
function cmd.wound(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"id:<number>")
	if not (wrd) then return end

	local id
	local vo
	if (string.find(txt,"id:")) then
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end

		vo = level.object_by_id(id)
		if not (vo) then
			return "wound:= Wrong arugument given or object doesn't exist. id:<%s>",id
		end
	end

	if (vo) then
		vo:set_health_ex(0.05)
		--[[
		local h = hit()
		h.power = vo.health+0.05
		h.direction = VEC_ZERO
		h.bone = "bip01_spine"
		h.draftsman = vo
		h.impulse = 6000
		h.type = hit.wound
		vo:hit(h)
		--]]
		return "wound:= %s has been wounded.",vo:name()
	end
end

-- Psy Wound
function cmd.psy_wound(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"id:<number>")
	if not (wrd) then return end

	local id
	local vo
	if (string.find(txt,"id:")) then
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end

		vo = level.object_by_id(id)
		if not (vo) then
			return "psy_wound:= Wrong arugument given or object doesn't exist. id:<%s>",id
		end
	end

	if (vo) then
		-- local h = hit()
		-- h.power = 100*(vo.health-0.05)
		-- h.direction = VEC_ZERO
		-- h.bone = "bip01_spine"
		-- h.draftsman = alun_utils.get_nearest_stalker(vo) or db.actor
		-- h.impulse = 0
		-- h.type = hit.telepatic
		-- vo:hit(h)
		vo.psy_health = -0.95
		return "psy_wound:= %s has been wounded.",vo:name()
	end
end

local var_list = { ["actor"] = db.actor}
function get_var_list()
	return var_list
end

-- Var
function cmd.var(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<name> $code$")
	if not (wrd) then return end

	if (wrd == "clear") then
		for k,v in pairs(var_list) do
			var_list[k] = nil
		end
		return "var:= All vars cleared"
	end

	if (wrd == "list") then
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1
		local sz = owner.console_size-1

		if not (sz) or (sz == 0) then return "var:= error" end

		local list_sz = 0
		for k,v in pairs(var_list) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "var:= Invaild page"
		end

		owner:SendOutput("var:= Variable List [%s of %s]",page,page_count)

		local a = {}
		for n in pairs(var_list) do table.insert(a, n) end
		table.sort(a)

		local ind, out, k
		for i=1,sz do
			ind = (page*sz - sz) + i
			k = ind > 0 and a[ind]
			out = " "

			if (k) then
				local v = var_list[k]
				if ( type(v) == "userdata" ) then
					out = string.format("%s = %s",k,"userdata")
					if (v.name and type(v.name) == "function" ) then
						out = string.format("%s = userdata [%s]",k,v:name())
					elseif (v.position) then
						local pos
						if (type(v.position) == "function") then
							pos = v:position()
							out = string.format("%s = userdata [%s,%s,%s]",k,pos.x,pos.y,pos.z)
						else
							pos = v.position
							out = string.format("%s = userdata [%s,%s,%s]",k,pos.x,pos.y,pos.z)
						end
					elseif (v.x and v.y and v.z) then
						out = string.format("%s = userdata [%s,%s,%s]",k,v.x,v.y,v.z)
					end
				elseif ( type(v) == "number" or type(v) == "string" or type(v) == "table" or type(v) == "function") then
					out = string.format("%s = %s",k,v)
				end
			end
			owner:SendOutput(out)
		end
		return
	end

	if (wrd) then
		var_list[wrd] = p[1]
		return "var:= variable %s set.",wrd
	end
end

-- Vector
function cmd.vector(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{add|sub}")
	if not (wrd) then return end

	if (wrd == "add") then
		local inc = {}

		inc.v = match_or_var(txt,"v:",".%S+",p[1])

		if not (inc.v) then
			return "vector:= Wrong arugument given to inc -> v:"
		end

		inc.x = tonumber( match_or_var(txt,"x:",".%S+",p[2]) ) or 0
		inc.y = tonumber( match_or_var(txt,"y:",".%S+",p[3]) ) or 0
		inc.z = tonumber( match_or_var(txt,"z:",".%S+",p[4]) ) or 0

		inc.v = inc.v:add( vector():set(inc.x,inc.y,inc.z) )
		return "vector:= vector updated to vector"
	end

	if (wrd == "sub") then
		local v = {}

		v[1] = match_or_var(txt,"1:",".%S+",p[1])
		v[2] = match_or_var(txt,"2:",".%S+",p[2])

		if (v[1] and v[2]) then
			local p1,p2
			if ( type(v[1]) == "string" ) then
				p1 = level.object_by_id( tonumber(p1) ):position()
			else
				p1 = v[1]
			end

			if ( type(v[2]) == "string" ) then
				p2 = level.object_by_id( tonumber(p2) ):position()
			else
				p2 = v[2]
			end

			local pr = p1 and p2 and p1:sub(p2)
			if (pr) then
				return "vector:= %s,%s,%s",pr.x,pr.y,pr.z
			end
		end
		return "vector:= Wrong arugument given or object(s) do not exist."
	end
end

-- Offset
function cmd.offset(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{get}")
	if not (wrd) then return end

	if (wrd == "get") then

		if (string.find(txt,"help")) then
			return "offset get [ 1:<id> 2:<id> | 1:<$var$> 2:<$var$> ]"
		end

		local v = {}
		v[1] = match_or_var(txt,"1:",".%S+",p[1])
		v[2] = match_or_var(txt,"2:",".%S+",p[2])

		if (v[1] and v[2]) then
			local p1,p2
			if ( type(v[1]) == "string" ) then
				p1 = level.object_by_id( tonumber(p1) )
			else
				p1 = v[1]
			end

			if ( type(v[2]) == "string" ) then
				p2 = level.object_by_id( tonumber(p2) )
			else
				p2 = v[2]
			end

			local pr = get_position_offset(v[1],v[2])
			if (pr) then
				return "offset:= position(%s,%s,%s)",pr.x,pr.y,pr.z
			end
		else
			return "offset:= type offset get help"
		end
	end

end

function cmd.object(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{count}")
	if not (wrd) then return end
	
	if (wrd == "count") then
		local count = 0
		local a = alife()
		for id, se_obj in a:objects() do 
			count = count + 1
		end
		return "object:= there are %s ids in use.",count
	end
	return "object:= try object count <number>"
end 

function get_position_offset(npc,o)
	local sec = o and type(o.section) == "function" and o:section()
	if not (sec) then
		return
	end

	local attach_bone_name = system_ini():r_string_ex(sec,"attach_bone_name")
	if not (attach_bone_name) then
		return
	end
	local pos1 = alun_utils.safe_bone_pos(npc,attach_bone_name)--npc:bone_position(attach_bone_name)
	local pos2 = o:center()
	return pos1:sub(pos2)
end

function match_or_var(txt,token,pat,var)
	if (var and var_list[var]) then
		return var_list[var]
	end

	if (string.find(txt,token)) then
		local v
		for s in string.gmatch(txt,token.."("..pat..")") do
			v = s
		end
		return v
	end
end

-- Hud
function cmd.hud(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		utils.save_var(db.actor,"disable_debug_draw",false)
		return "hud:= debug hud enabled"
	end

	if (wrd == "off") then
		utils.save_var(db.actor,"disable_debug_draw",true)
		return "hud:= debug hud disabled"
	end

	return "hud:= type hud help for list of sub commands"
end

-- God
function cmd.god(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		xrs_debug_tools.debug_god = true
		--get_console():execute("g_god on")
		return "god:= invincibility enabled"
	end

	if (wrd == "off") then
		xrs_debug_tools.debug_god = nil
		--get_console():execute("g_god off")
		return "god:= invincibility disabled"
	end

	return "god:= type god help for list of sub commands"
end

-- Invisible
function cmd.invisible(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		xrs_debug_tools.debug_invis = true
		return "invisible:= invisibility enabled"
	end

	if (wrd == "off") then
		xrs_debug_tools.debug_invis = nil
		return "invisible:= invisibility disabled"
	end

	return "invisible:= type invisible help for list of sub commands"
end

local crow_fun
function cmd.crow(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		local se_crow = alun_utils.nearest_object("m_crow")
		if (se_crow) then
			local function mount_crow()
				if (crow_fun) then
					db.actor:set_actor_position(se_crow.position)
					return false
				end 
				return true
			end
			crow_fun = true
			AddUniqueCall(mount_crow)
			return "crow:= enabled"
		end
		return "crow:= no crows found"
	end

	if (wrd == "off") then
		crow_fun = nil
		return "crow:= disabled"
	end

	return "crow:= type crow help for list of sub commands"
end

local heli_id
function cmd.heli(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[spawn|move|mount|dismount]")
	if not (wrd) then return end

	if (wrd == "spawn") then
		local se_heli = stpk_utils.spawn_heli()
		if (se_heli) then
			heli_id = se_heli.id
			return "heli:= Spawned at actor position"
		end
		return "heli:= Spawning failed"
	end

	if (wrd == "move") then
		local str
		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:(.%S+)") do
				str = s
			end
		end

		if (str and str ~= "") then
			str = str_explode(str,",")
			str.x = tonumber(str[1])
			str.y = tonumber(str[2])
			str.z = tonumber(str[3])
		end

		local obj = level.object_by_id(heli_id)
		local heli = obj and obj:get_helicopter()
		if (heli) then
			local pos = str or db.actor:position()
			heli:SetDestPosition(vector():set(pos.x,pos.y,pos.z))
			return "heli:= destination set to actor position"
		end
		return "heli:= move failed"
	end

	if (wrd == "mount") then
		local heli
		for id,o in pairs(db.heli) do
			heli = o
			break
		end
		if (heli) then
			db.actor:attach_vehicle(heli)
			return "heli:= mounted"
		end
		return "heli:= not found"
	elseif (wrd == "dismount") then 
		db.actor:detach_vehicle()
		return "heli:= dismounted"
	end
	return "heli:= type heli help for list of sub commands"
end

-- weather
local weather_list
function cmd.weather(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[list <page> | set <weather_name>]")
	if not (wrd) then return end

	if (wrd == "list") then
		if not (weather_list) then
			weather_list = {}
			local f = getFS()
			local flist = f:file_list_open("$game_weathers$",1)
			local f_cnt = flist:Size()

			for	it=0, f_cnt-1 do
				local file = flist:GetAt(it)
				table.insert(weather_list,file)
			end
			
			flist:Free()
		end

		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1

		local sz = owner.console_size

		if not (sz) or (sz == 0) then return "weather:= error" end

		local list_sz = 0
		for k,v in pairs(weather_list) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "weather:= Invaild page"
		end

		table.sort(weather_list)

		owner:SendOutput("weather:= Weathers List [%s of %s]",page,page_count)
		owner:SendOutputList(weather_list,(page*sz)-sz,sz-1)

		return
	elseif (wrd == "set") then
		level.set_weather(rest,true)
		return "weather:= weather set to " .. rest
	end
	return "weather: type weather help for a list of commands. Exclude .ltx when setting weather"
end

-- time
function cmd.time(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[day,hour,minute]")
	if not (wrd) then return end

	local t = alun_utils.str_explode(txt,",")
	if (t) then
		--set_current_time(tonumber(t[1]),tonumber(t[2]),tonumber(t[3]))
		level.change_game_time( tonumber(t[1]),tonumber(t[2]),tonumber(t[3]) )
		level_weathers.get_weather_manager():forced_weather_change()
	end
end

-- money
function cmd.money(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<amount>")
	if not (wrd) then return end
	local amt = tonumber(wrd) or 1000
	db.actor:give_money(amt)
	return "money:= gave actor "..amt.." RU. You dirty cheater, I'm going to find you and cut your legs off!"
end

-- luabind (not working)
function cmd.luabind(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[list | info]")
	if not (wrd) then return end
	
	if (wrd == "list") then
		if not (_G.class_names) then 
			return "luabind:= error no class_names()"
		end 
		
		local class_names = _G.class_names()
		table.sort(class_names)
		
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1

		local sz = owner.console_size

		if not (sz) or (sz == 0) then return "luabind:= error" end

		local list_sz = 0
		for k,v in pairs(class_names) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "luabind:= Invaild page"
		end

		owner:SendOutput("luabind:= class_names() [%s of %s]",page,page_count)
		owner:SendOutputList(class_names,(page*sz)-sz,sz-1)
		return
	elseif (wrd == "info") then 
		if not (_G.class_info) then 
			return "luabind:= error no class_info()"
		end 
		
		if (string.find(txt,"help")) then
			return "luabind select userdata:<$var$>"
		end

		local v = {}
		v[1] = match_or_var(txt,"userdata:",".%S+",p[1])
		if (v[1]) then
			local c = class_info(v[1])
			if not (c) then 
				return "luabind:= error; no class info for userdata (not luabind class?)"
			end
			wrd = ""
			local _strt, _end = string.find(txt,"%d+")
			if (_strt and _end) then
				wrd = string.sub(txt,_strt, _end)
				wrd = string.lower(wrd)
			end

			local page = wrd ~= "" and tonumber(wrd) or 1

			local sz = owner.console_size

			if not (sz) or (sz == 0) then return "luabind:= error" end

			local list_sz = 0
			for k,v in pairs(class_names) do
				list_sz = list_sz + 1
			end

			local page_count = math.ceil(list_sz/sz)

			if (page > page_count) then
				return "luabind:= invaild page"
			end
			owner:SendOutput("luabind:= class=%s",c.name)
			owner:SendOutputList(c.methods,(page*sz)-sz,sz-1)
			return
		else
			return "luabind:= no class/userdata specified. (ex. luabind select userdata:$npc$)"
		end 
	end
	return "luabind:= type luabind help for a list of commands"
end 

-- level
function cmd.level(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<name> | [list]")
	if not (wrd) then return end

	if (wrd == "list") then

		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end
		local page = wrd ~= "" and tonumber(wrd) or 1

		local levels = alun_utils.collect_section(game_ini(),"level_maps_single")

		local sz = owner.console_size
		local list_sz = 0
		for k,v in pairs(levels) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "level:= Invaild page"
		end

		owner:SendOutput("level:= list of available levels by name [%s of %s]",page,page_count)
		owner:SendOutputList(levels,(page*sz)-sz,sz-1)

		return
	end
	
	local level_name = level.name()
	if (JumpToLevel(wrd)) then 
		return "level:= level changer successfully created at your position from"..level_name.." to "..wrd.." (Spawning at first found gvid)"
	end

	--[[ depreciated
	local levels = { 	["zaton_jupiter"] = {467.306884765625,55.5276184082031,12.9044094085693},
						["zaton_pripyat"] = {467.206878662109,55.5276184082031,3.20440793037415},
						["jupiter_zaton"] = {-7.12386798858643,14.484338760376,154.085464477539},
						["jupiter_jupiter_underground"] = {460.005798339844,46.0688896179199,-295.460784912109},
						["jupiter_pripyat"] = {-16.3238716125488,14.484338760376,142.785461425781},
						["pripyat_zaton"] = {150.91047668457,22.3456954956055,-287.9228515625},
						["pripyat_jupiter"] = {139.08171081543,22.3457069396973,-287.870025634766},
						["pripyat_labx8"] = {-78.0360107421875,-7.04113388061523,100.684921264648},
						["labx8_pripyat"] = {-78.062873840332,23.8045539855957,100.718994140625}
	}
	local level_name = level.name()
	if (levels[level_name.."_"..wrd]) then
		db.actor:set_actor_position(vector():set(levels[level_name.."_"..wrd][1],levels[level_name.."_"..wrd][2],levels[level_name.."_"..wrd][3]))
		return "level:= teleporting player from "..level_name.." to "..wrd
	end

	local sim = alife()
	local gg = game_graph()
	local level,data
	local default_vertex
	local function create_lc(gvid,vertex)
		local se_obj = sim:create("level_changer",db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
		if (se_obj) then
			bind_stalker_ext.REMOVE_ME_LC = se_obj.id
			local lvid = vertex:level_vertex_id()
			local pos = vertex:level_point()

			data = stpk_utils.get_level_changer_data(se_obj)
			if (data) then
				data.dest_game_vertex_id = gvid
				data.dest_level_vertex_id = lvid
				data.dest_position = pos
				data.dest_direction = VEC_ZERO
				data.dest_level_name = level
				data.silent_mode = 1
				
				data.shapes[1] = {}
				data.shapes[1].shtype = 0
				data.shapes[1].offset = VEC_ZERO
				data.shapes[1].radius = 5
				
				data.hint = "level_changer_invitation"

				stpk_utils.set_level_changer_data(data,se_obj)
			end
		end
	end 
	
	for gvid=0, 4836 do
		if gg:valid_vertex_id(gvid) then
			vertex = gg:vertex(gvid)
			level = sim:level_name(vertex:level_id())
			if (level == wrd) then
				if (not vertex.name or string.find(vertex:name(),"actor_spawn")) then
					create_lc(gvid,vertex)
					return "level:= level changer successfully created at your position from"..level_name.." to "..wrd.." (Actor spawn point found!)"
				elseif not (default_vertex) then
					default_vertex = vertex
				end
			end
		else
			break
		end
		gvid = gvid + 1
	end
	
	if (default_vertex) then 
		create_lc(gvid,vertex)
		return "level:= level changer successfully created at your position from"..level_name.." to "..wrd.." (Spawning at first found gvid)"
	end
	--]]

	return "level:= there is no level changer between "..level_name.." and "..wrd
end

function cmd.warpall(me,txt,owner,p)
	local levels = alun_utils.collect_section(game_ini(),"level_maps_single")
	if (levels[1]) then
		utils.save_var(db.actor,"debug_warpall",1)
		_G.JumpToLevel(levels[1])
	end
	return "warpall := warping to every single level then flushing log"
end

-- dev_debug
function cmd.dev_debug(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on | off]")
	if not (wrd) then return end
	if (wrd == "on") then
		_G.DEV_DEBUG = true
	elseif (wrd == "off") then
		_G.DEV_DEBUG = false
	end
	return "dev_debug:= type dev_debug help for list of sub commands."
end

-- game_graph
function cmd.game_graph(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[show | near | checkall]")
	if not (wrd) then return end

	if (wrd == "show") then
		local gg = game_graph()
		local vertex, level_name, lvid, pos, se_obj
		local sim = alife()
		local gvid = 0
		local lgvid = 0
		local level = level
		while gg:valid_vertex_id(gvid) do
			vertex = gg:vertex(gvid)
			level_name = alife():level_name(vertex:level_id())
			lvid = vertex:level_vertex_id()
			pos = vertex:level_point()

			se_obj = sim:create("medkit", pos, lvid, gvid)
			level.map_add_object_spot_ser(se_obj.id, "treasure", level_name.." Gvid:"..gvid)

			if (level_name == level.name()) then
				lgvid = lgvid + 1
			end
			gvid = gvid + 1
		end
		return "game_graph:= spots created. There are "..lgvid.." in "..level.name().." and "..gvid.." total."
	elseif (wrd == "near") then
		local gg = game_graph()
		local vertex, level_name, lvid, pos
		local near_lvid, near_dist, near_gvid, dist
		local gvid = 0
		local lgvid = 0
		local level = level
		while gg:valid_vertex_id(gvid) do
			vertex = gg:vertex(gvid)
			level_name = alife():level_name(vertex:level_id())
			if (level_name == level.name()) then
				pos = vertex:level_point()

				dist = db.actor:position():distance_to_sqr(pos)

				if not (near_dist) then
					near_gvid = gvid
					near_dist = dist
				end

				if (dist < near_dist) then
					near_gvid = gvid
					near_dist = dist
				end
				lgvid = lgvid + 1
			end
			gvid = gvid + 1
		end
		return "game_graph:= nearest gvid = " .. near_gvid .. " [dist = " .. near_dist .. "] There are "..lgvid.." in "..level.name().." and "..gvid.." total."
	elseif (wrd == "checkall") then
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end
		local page = wrd ~= "" and tonumber(wrd) or 1
		
		local issues = {}
		local gg = game_graph()
		local vertex
		local sim = alife()
		for id, se_obj in sim:objects() do
			if not (gg:valid_vertex_id(se_obj.m_game_vertex_id)) then
				issues[#issues+1] = se_obj:name()
			end
		end
		
		if (#issues == 0) then 
			return "game_graph:= no issues found"
		end
		
		local sz = owner.console_size
		local page_count = math.ceil(#issues/sz)

		if (page > page_count) then
			return "game_graph:= Invalid page"
		end

		owner:SendOutput("game_graph:= list of objects with invalid game_vertex_ids [%s of %s]",page,page_count)
		owner:SendOutputList(issues,(page*sz)-sz,sz-1)
		return
	end
	return "game_graph:= type game_graph help for list of commands"
end

-- item
function cmd.item(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[list <page> ]")
	if not (wrd) then return end

	if (wrd == "list") then
		if not (se_item.registered_items) then
			return "item:= error no registered_items list"
		end

		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1
		local sz = owner.console_size - 1

		if not (sz) or (sz == 0) then return "item:= error" end

		local list_sz = 0
		for k,v in pairs(se_item.registered_items) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "item:= Invaild page"
		end

		owner:SendOutput("item:= Registered Item List [%s of %s]",page,page_count)

		local a = {}
		for n in pairs(se_item.registered_items) do table.insert(a, n) end
		table.sort(a)

		local ind, out, k
		for i=1,sz do
			ind = (page*sz - sz) + i
			k = ind > 0 and a[ind]
			out = " "
			if (k) then
				out = string.format("%s [count: %s]",k,se_item.registered_items[k])
			end
			owner:SendOutput(out)
		end
		return
	end
	return "item:= type item help for a list of subcommands"
end

-- info
function cmd.info(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[list <page> | clear | give | take | save <filename> | load <filename> ]")
	if not (wrd) then return end

	if (wrd == "give") then
		give_info(rest)
		return "info:= info given"
	elseif (wrd == "take") then
		disable_info(rest)
		return "info:= disabled"
	elseif (wrd == "clear") then
		local info_list = {}
		local function itr(id,info)
			table.insert(info_list,info)
		end
		alife():iterate_info(0,itr)
		for i,info in ipairs(info_list) do 
			disable_info(info)
		end
		return "info:= all info portions removed from actor"
	elseif (wrd == "list") then
		local info_list = {}
		local function itr(id,info)
			table.insert(info_list,info)
		end
		alife():iterate_info(0,itr)
		
		local list_sz = #info_list
		if (list_sz == 0) then 
			return "info:= actor_info empty"
		end

		wrd = ""
		local _strt, _end = string.find(rest,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1

		local sz = owner.console_size-1

		if not (sz) or (sz == 0) then return "info:= error" end

		local page_count = math.ceil(list_sz/sz)
		if (page > page_count) then
			return list_sz > 0 and "info: nothing in list" or "info:= Invaild page"
		end

		owner:SendOutput("info:= Infoportions [%s of %s]",page,page_count)

		table.sort(info_list)

		local ind, out, k
		for i=1,sz do
			ind = (page*sz - sz) + i
			k = ind > 0 and info_list[ind]
			owner:SendOutput(k or " ")
		end
		return
	elseif (wrd == "save") then
		if (rest == nil or rest == "") then 
			return "info:= save command must have a filename! ex. info save my_list"
		end 
		
		local info_list = {}
		local function itr(id,info)
			table.insert(info_list,info)
		end
		alife():iterate_info(0,itr)
		table.sort(info_list)
		
		str = "[info]\n"
		for i,info in ipairs(info_list) do 
			str = str .. info .. "\n"
		end
		
		local cfg = io.open(rest .. ".ltx","w+")
		cfg:write(str)
		cfg:close()
	
		return "info:= save was a success!"	
	elseif (wrd == "load") then
		if (rest == nil or rest == "") then 
			return "info:= load command must have a filename! ex. info load my_list"
		end
		
		local info_ini = alun_utils.cfg_file(rest..".ltx",true)
		if not (info_ini) then 
			return "info:= failed to load " .. rest
		end
		
		-- give all infos
		for field,value in pairs(info_ini.root["info"]) do 
			give_info(field) 
		end

		return "info:= load was a success!"
	end
	return "info:= type info help for a list of subcommands"
end

-- cmd.inventory_owner
function cmd.inventory_owner(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[removeall]")
	if (wrd == "removeall") then 
		wrd = first_word(rest)
		if (wrd == "help") then 
			return "inventory_owner:= try 'inventory_owner removeall id:<number>'"
		end 
		
		local id
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end
		if not (id) then
			return "inventory_owner:= type 'inventory_owner removeall help'"
		end
		
		local sim = alife()
		local count = 0
		for id, se_obj in sim:objects() do
			if (se_obj.parent_id == id) then 
				sim:release(se_obj,true)
				count = count + 1
			end
		end
		if (count > 0) then 
			return "inventory_owner:= removed %s children from inventory_owner",count
		end
		return "inventory_owner:= failed to remove any children from inventory_owner"
	end
	return "inventory_owner:= type 'inventory_owner help' for a list of subcommands"
end 

-- cmd.antifreeze
function antifreeze_switch(id)
	local sim = alife()
	local se_obj = sim:object(id)
	if not (se_obj) then 
		return true 
	end 
	if (se_obj:can_switch_offline()) then
		alun_utils.switch_offline(se_obj.id)
	elseif (se_obj:can_switch_online()) then
		alun_utils.switch_online(se_obj.id)
	end
	return true
end 
function cmd.antifreeze(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[npc [<time>]] (ex.1: antifreeze 5 | ex.2: antifreeze npc 5)")
	
	local function tele_to_actor(id)
		local sim = alife()
		local se_obj = sim:object(id)
		if not (se_obj) then 
			return true 
		end
		local cls = se_obj:clsid()
		if (cls == clsid.online_offline_group_s) then
			TeleportSquad(se_obj,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
		elseif (IsStalker(nil,cls) or IsMonster(nil,cls)) then 
			if (alife().teleport_object) then 
				alife():teleport_object(se_obj,db.actor:game_vertex_id(),db.actor:level_vertex_id(),db.actor:position())
			end
		end
		return true
	end  
	
	local function repeater(a)
		CreateTimeEvent(a,"antifreeze",wrd,antifreeze_switch,a)
		return false
	end
	
	if (wrd == "npc") then 
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		wrd = wrd ~= "" and tonumber(wrd) or 5

		se_obj = alife():create("sim_default_stalker_0", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
		if not (se_obj) then 
			return "antifreeze:= failed to create stalker "
		end
		CreateTimeEvent(se_obj.id,"repeater",10,repeater,se_obj.id)
	else 
		wrd = tonumber(wrd) or 5 
		
		if not (smart_terrain.nearest_to_actor_smart.id) then 
			return "antifreeze:= no nearest smart"
		end 
		
		local smart = alife_object(smart_terrain.nearest_to_actor_smart.id)
		if not (smart) then 
			return "antifreeze:= smart by id " .. smart_terrain.nearest_to_actor_smart.id .. "does not exist."
		end 
		
		local se_obj = SIMBOARD:create_squad(smart,"stalker_sim_squad_novice")
		if not (se_obj) then 
			return "antifreeze:= failed to create squad "
		end 
		
		se_obj.scripted_target = "actor"
		
		CreateTimeEvent(se_obj.id,"teleport",1,tele_to_actor,se_obj.id)
		CreateTimeEvent(se_obj.id,"repeater",1,repeater,se_obj.id)
	end
	
	return "antifreeze:= created object and teleported to your position!"
end 

function cmd.pstor_test(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"saves 2000 boolean to db.actor using pstor_store")
	if not (db.actor) then 
		return "pstor_test:= actor not present"
	end 
	
	for _ = 1, 2000 do
		local var = tostring( math.random() ):sub( 1, 10 )
		local val = tostring( math.random() ):sub( 1, 10 )
		printf("%s | %s",var,val)
		utils.save_var( db.actor, var, val )
	end

	return "pstor_test:= successfully saved 2000 values to db.actor pstor"
end


function setup_debug_logic(npc,st,loaded)
	local ltx_name = "scripts\\debug_npc.ltx"
	local ltx = ini_file(ltx_name)
	if not (ltx) then 
		return
	end
	
	local id = npc:id()
	local sim = alife()
	local se_npc = sim:object(id)
	local unreg_id = se_npc and se_npc.m_smart_terrain_id
	if (unreg_id and unreg_id ~= 65535) then
		local unreg = sim:object(unreg_id)
		if (unreg) then
			unreg:unregister_npc(se_npc)
		end
	end
	
	xr_logic.configure_schemes(npc, ltx, ltx_name, modules.stype_stalker, loaded and st.loaded_section_logic or "logic", "")
	
	local section = loaded and st.loaded_active_section or xr_logic.determine_section_to_activate(npc, ltx, "logic", db.actor)
	xr_logic.activate_by_section(npc, ltx, section, "", loaded)
	--printf("setup complete")
end 
debug_visuals = nil
function cmd.debug_visuals(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[all|<visual_name>]")
	if (wrd) and (wrd == "all" or wrd ~= "") then
		local check_all = wrd == "all"
		
		debug_visuals = {}
		
		local gvid = db.actor:game_vertex_id()
		local pos = db.actor:position()

		local dist = 1
		local f = getFS()
		local flist = f:file_list_open_ex("$game_meshes$",bit_or(FS.FS_ListFiles),"*.ogf")
		local f_cnt = flist:Size()
		for	it=0, f_cnt-1 do
			local file = flist:GetAt(it)
			local visual_name = file:NameFull():sub(1,-5)

			if (check_all or string.find(visual_name,wrd)) then
				if (string.find(visual_name,"actors\\") == 1 and not string.find(visual_name,"trader") and not string.find(visual_name,"lesnik")) then
					local newpos = vector():set(pos)
					newpos:add(vector():set(device().cam_dir):mul(dist))
					newpos = vector():set(newpos.x,pos.y,newpos.z)
					local lvid = level.vertex_id(newpos)
					local se_obj = alife():create("sim_default_stalker_0",newpos,lvid,gvid)
					if (se_obj) then
						alife():create("wpn_pkm",se_obj.position,se_obj.m_level_vertex_id,se_obj.m_game_vertex_id,se_obj.id)
						--printf("%s visual:= %s",se_obj:name(),visual_name)
						debug_visuals[se_obj.id] = visual_name
					end
					dist = dist + 1
				end
			end
		end
		return "debug_visuals:= done!"
	end
	return "debug_visuals:= type debug_visuals help for a list of subcommands."
end

function cmd.gulag(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[export]")
	if (wrd) then
		if (wrd  == "export") then 
			local sim = alife()
			for id, se_obj in sim:objects() do
				if (se_obj:clsid() == clsid.smart_terrain) then 
					gulag_general.load_job(se_obj,true)
				end
			end
		end
	end
	return "gulag:= type gulag help for a list of subcommands."
end