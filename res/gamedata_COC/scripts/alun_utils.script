--[[
	
--]]

function get_inv_name(section)
	return game.translate_string(system_ini():r_string_ex(section,"inv_name"))
end 

-- Prints a formated lua table to print_table.txt for debugging purposes
function print_table(node,header,format_only)
	-- to make output beautiful
	local function tab(amt)
		local str = ""
		for i=1,amt do
			str = str .. "\t"
		end
		return str
	end

	local cache, stack = {},{}
	local depth = 1
	local output_str = header and ("-- " .. tostring(header) .. "\n{\n") or "{\n"
	local output = {}
	local size_t = 0
	local size_stack = 0 
	while true do
		local size = table.size(node)
		local cur_index = 1
		for k,v in pairs(node) do
			if (cache[node] == nil) or (cur_index >= cache[node]) then
				if (string.find(output_str,"}",output_str:len())) then
					output_str = output_str .. ",\n"
				elseif not (string.find(output_str,"\n",output_str:len())) then
					output_str = output_str .. "\n"
				end
				
				size_t = size_t + 1
				output[size_t] = output_str
				output_str = ""

				local key
				if (type(k) == "number" or type(k) == "boolean") then
					key = "["..tostring(k).."]"
				else
					key = "['"..tostring(k).."']"
				end

				if (type(v) == "number" or type(v) == "boolean") then
					output_str = output_str .. tab(depth) .. key .. " = "..tostring(v)
				elseif (type(v) == "table") then
					output_str = output_str .. tab(depth) .. key .. " = {\n"
					size_stack = size_stack + 1
					stack[size_stack] = node
					size_stack = size_stack + 1
					stack[size_stack] = v
					cache[node] = cur_index+1
					break
				elseif (type(v) == "userdata") then
					if (v.diffSec) then
						local Y, M, D, h, m, s, ms = 0,0,0,0,0,0,0
						Y, M, D, h, m, s, ms = v:get(Y, M, D, h, m, s, ms)
						output_str = strformat("%s%s%s = { Y=%s, M=%s, D=%s, h=%s, m=%s, s=%s, ms=%s } ",output_str,tab(depth),key,Y, M, D, h, m, s, ms)
					else
						output_str = output_str .. tab(depth) .. key .. " = userdata"
					end
				else
					output_str = output_str .. tab(depth) .. key .. " = '"..tostring(v).."'"
				end

				if (cur_index == size) then
					output_str = output_str .. "\n" .. tab(depth-1) .. "}"
				else
					output_str = output_str .. ","
				end
			else
				-- close the table
				if (cur_index == size) then
					output_str = output_str .. "\n" .. tab(depth-1) .. "}"
				end
			end

			cur_index = cur_index + 1
		end
		
		if (size == 0) then
			output_str = output_str .. "\n" .. tab(depth-1) .. "}"
		end

		if (size_stack > 0) then
			node = stack[size_stack]
			stack[size_stack] = nil
			size_stack = size_stack - 1
			depth = cache[node] == nil and depth + 1 or depth - 1
		else
			break
		end
	end
   
	size_t = size_t + 1
	output[size_t] = output_str

	output_str = table.concat(output)
	
   	if (format_only) then
		return output_str
	end
	
	local file = io.open("print_table.txt","a+")
	file:write(output_str.."\n\n")
	file:close()
	printf("Table written to print_table.txt")
end


function valid_vertex(npc,vid)
	return vid and vid < 4294967295 and npc:accessible(vid) and vid
end

function accessible(npc,point)
	if (type(point) == "number") then
		return point < 4294967295 and npc:accessible(point)
	end
	return level.vertex_id(point) < 4294967295 and npc:accessible(point)
end

function is_in_same_squad(obj,npc)
	local squad1 = get_object_squad(obj)
	local squad2 = get_object_squad(npc)
	if ( squad1 and squad2 ) then
		if ( squad1.id == squad2.id ) then
			return true
		end
	end
	return false
end

function read_from_ini(ini,section,line,var_type,default,caller)
	if not (ini) then
		ini = system_ini()
	end
	if not (section) then 
		printf("ERROR: alun_utils.read_from_ini trying to read nil section! line=%s var_type=%s default=%s caller=%s",line,var_type,default,caller)
	end

	if (section and line and ini:section_exist(section) and ini:line_exist(section,line)) then
		if (var_type == "bool") then
			return ini:r_bool_ex(section,line)
		elseif (var_type == "string") then
			return ini:r_string_ex(section,line)
		elseif (var_type == "float") then
			return ini:r_float_ex(section,line)
		else
			return ini:r_string_wq(section,line)
		end
	end
	return default
end

function trim(s)
	return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

function parse_ini_section_to_array(ini,section)
	local tmp=nil
	if ini and ini:section_exist(section) then
		tmp={}
		for a=0,ini:line_count(section)-1 do
			local result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end

function str_explode(str,sep,plain)
	if not (sep ~= "" and string.find(str,sep,1,plain)) then
		return { str }
	end
	local t = {}
	local size = 0
	for s in str:gsplit(sep,plain) do 
		size = size + 1
		t[size] = trim(s)
	end
	return t
end

function hex2string(str)
    return (str:gsub('..', function (cc)
        return string.char(tonumber(cc, 16))
    end))
end

function string2hex(str)
    return (str:gsub('.', function (c)
        return string.format('%02X', string.byte(c))
    end))
end

function float2hex (n)
    if n == 0.0 then return 0.0 end

    local sign = 0
    if n < 0.0 then
        sign = 0x80
        n = -n
    end

    local mant, expo = math.frexp(n)
    local hext = {}

    if mant ~= mant then
        hext[#hext+1] = string.char(0xFF, 0x88, 0x00, 0x00)

    elseif mant == math.huge or expo > 0x80 then
        if sign == 0 then
            hext[#hext+1] = string.char(0x7F, 0x80, 0x00, 0x00)
        else
            hext[#hext+1] = string.char(0xFF, 0x80, 0x00, 0x00)
        end

    elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
        hext[#hext+1] = string.char(sign, 0x00, 0x00, 0x00)

    else
        expo = expo + 0x7E
        mant = (mant * 2.0 - 1.0) * math.ldexp(0.5, 24)
        hext[#hext+1] = string.char(sign + math.floor(expo / 0x2),
                                    (expo % 0x2) * 0x80 + math.floor(mant / 0x10000),
                                    math.floor(mant / 0x100) % 0x100,
                                    mant % 0x100)
    end

    return tonumber(string.gsub(table.concat(hext),"(.)",
                                function (c) return string.format("%02X%s",string.byte(c),"") end), 16)
end


function hex2float (c)
    if c == 0 then return 0.0 end
    local c = string.gsub(string.format("%X", c),"(..)",function (x) return string.char(tonumber(x, 16)) end)
    local b1,b2,b3,b4 = string.byte(c, 1, 4)
    local sign = b1 > 0x7F
    local expo = (b1 % 0x80) * 0x2 + math.floor(b2 / 0x80)
    local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

    if sign then
        sign = -1
    else
        sign = 1
    end

    local n

    if mant == 0 and expo == 0 then
        n = sign * 0.0
    elseif expo == 0xFF then
        if mant == 0 then
            n = sign * math.huge
        else
            n = 0.0/0.0
        end
    else
        n = sign * math.ldexp(1.0 + mant / 0x800000, expo - 0x7F)
    end

    return n
end

function parse_list(ini,key,val,convert)
	if not (ini) then 
		error(strformat("alun_utils.parse_list ini is nil for key=%s val=%s",key,val))
	end
	local str = ini:r_string_ex(key,val)
	local t = str and str ~= "" and str_explode(str,",") or {}
	if (convert and #t > 0) then
		local l = {}
		for i=1,#t do
			l[t[i]] = true
		end
		return l
	end
	return t
end

function collect_sections(ini,sections)
	local r,p = {},{}
	for k=1,#sections do
		local v = sections[k]
		if ini:section_exist(v) then
			local n = ini:line_count(v)
			if n > 0 then
				for i = 0,n-1 do
					local res,id,val = ini:r_line(v,i,"","")
					if r[id] == nil then
						r[id] = val
					end
				end
			end
			p[k] = n
		end
	end
	return r,p
end

local ranks
function get_rank_list()
	if ranks then
		return ranks
	end
	local tmp = parse_list(system_ini(),"game_relations","rating")
	ranks = {}
	for i,rn in ipairs(tmp) do
		if not tonumber(rn) then
			ranks[#ranks+1] = rn
		end
	end
	return ranks
end

local reputations
function get_reputation_name(value)
	reputations = reputations or parse_list(system_ini(),"game_relations","reputation_names")
	local prev = nil
	for i,rn in ipairs(reputations) do
		local repu = tonumber(rn)
		if (repu and value <= repu) then 
			return prev
		else
			prev = rn
		end
	end
	return prev
end

local communities
function get_communities_list()
	if communities then
		return communities
	end
	local tmp = parse_list(system_ini(),"game_relations","communities")
	communities = {}
	for i,cn in ipairs(tmp) do
		if not tonumber(cn) then
			communities[#communities+1] = cn
		end
	end
	return communities
end

function execute_script_on_squad(obj,script_to_execute,...)
	local squad = obj:clsid() == clsid.online_offline_group_s and obj or get_object_squad(obj)

	if not ( squad ) then
		script_to_execute(obj,...)
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object

		if ( member and member:alive() ) then
			script_to_execute(member,...)
		end
	end
end


function execute_script_on_squad_not_commander(obj,script_to_execute,...)
	local squad = obj:clsid() == clsid.online_offline_group_s and obj or get_object_squad(obj)

	if not ( squad ) then
		--script_to_execute(obj,...)
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object

		if ( member and member:alive() and member:id() ~= squad:commander_id() ) then
			script_to_execute(member,...)
		end
	end
end

function nearest_object(s,offline)
	local dist
	local nearest
	local min_dist
	local is_match
	for i=1, 65534 do
		local obj = alife_object(i)
		if (obj) then
			is_match = false
			if (type(s) == "string" and string.find(obj:name(),s)) then
				is_match = true
			elseif (type(s) == "number" and s == obj:clsid()) then
				is_match = true
			end

			if (is_match) then
				dist = obj.position:distance_to_sqr(db.actor:position())

				if not(min_dist) then
					min_dist = dist
					nearest = obj
				elseif (dist < min_dist) then
					min_dist = dist
					nearest = obj
				end
			end
		end
	end

	if (nearest) then
		if (simulation_objects.is_on_the_same_level(nearest, alife():actor())) then
			if (offline or min_dist <= alife():switch_distance()^2) then
				return nearest,min_dist
			end
		end
	end
end





-- level object only

function get_nearest_stalker(npc)
	if not (db.OnlineStalkers) then
		return
	end
	local stalker
	local dist
	local nearest_stalker,nearest_dist
	local is_cam = npc == "cam"
	local pos = is_cam and device().cam_pos or npc:position()
	local st
	for i=1, #db.OnlineStalkers do
		st = db.storage[db.OnlineStalkers[i]]
		stalker = st and st.object or level.object_by_id(db.OnlineStalkers[i])
		if (stalker and IsStalker(stalker) and stalker:alive()) then
			if (is_cam or npc:id() ~= stalker:id()) then
				dist = pos:distance_to_sqr(stalker:position())
				if not (nearest_dist) then
					nearest_dist = dist
					nearest_stalker = stalker
				end

				if (dist < nearest_dist) then
					nearest_dist = dist
					nearest_stalker = stalker
				end
			end
		end
	end
	return nearest_stalker,nearest_dist
end

function get_nearest_object(npc,...)
	local p = {...}
	local match
	local lowest_dist = p[2]
	for key, value in pairs(p[1]) do
		local obj
		if ( value.object ) then
			obj = value.object
		else
			obj = value
		end
		if ( obj and obj.position ) then
			dist = npc:position():distance_to_sqr(obj:position())

			if ( dist < lowest_dist ) then
				lowest_dist = dist
				match = obj
			end
		end
	end

	if ( match ) then
		return match,lowest_dist
	end
end

function get_squad_count(npc)
	local squad = get_object_squad(npc)

	if not ( squad ) then
		return 1
	end
	local c = 0
	for k in squad:squad_members() do
		c = c + 1
	end
	return c
end

function safe_release(p,force)
	local sim = alife()
	local se_obj = p[1] and sim:object(p[1])
	if not (se_obj) then
		return true
	end
	
	if (force) then 
		sim:release(se_obj,true)
	end

	-- wait for it to switch offline
	if (se_obj.online) then
		if (se_obj:can_switch_offline()) then
			se_obj:switch_offline()
		end
		return false
	end
	
	sim:release(se_obj,true)

	return true
end

function release(se_obj)
	if (se_obj) then
		local sim = alife()
		sim:release(se_obj,true)
	end
end

function create(p)
	--printf("section=%s position=%s lvid=%s gvid=%s",p[1],vector_to_string(p[2]),p[3],p[4])
	alife():create(p[1],p[2],p[3],p[4])
end

function get_current_action_id(npc)
	local mgr = npc:motivation_action_manager()

	if not mgr:initialized() then
		return false
	end

	return mgr:current_action_id()
end



function is_actor(object,c)
	if not (c) then
		c = object and object:clsid()
	end
	return c == clsid.script_actor or c == clsid.actor or c == clsid.spectator or object and object:id() == db.actor:id()
end

function add_anim(npc,anm)
	if anm then
		npc:add_animation(anm,true,false)
	end
end

function get_sound(snd)
	if snd then
		return sound_object(snd)
	end
end

function safe_bone_pos(obj,bone)
	local bone_id = obj:get_bone_id(bone)
	return obj:bone_position(bone_id == 65535 and "" or bone)
end

function is_level_changing()
	local sim = alife()
	local act = game_graph():vertex(sim:actor().m_game_vertex_id)
	return act:level_id() ~= sim:level_id()
end

--------------------------------------switch---------------------------------------
function switch_online(id)
	if id == -1 then return end
	local sim = alife()
	if sim then
		sim:set_switch_online(id,true)
		sim:set_switch_offline(id,false)
	end
end

function switch_offline(id)
	local sim = alife()
	if sim then
		sim:set_switch_online(id,false)
		sim:set_switch_offline(id,true)
	end
end

-------------------------------------------------------- DEBUG FUNCTION -------------------------------------------------
function debug_nearest(npc,msg,...)
	local dbg = xrs_debug_tools.get_debug_npc()
	local id = npc and npc.id and (type(npc.id) == "function" and npc:id() or npc.id)
	if (id and dbg and id == dbg:id()) then
		printf("nearest=%s |"..msg,npc:name(),...)
	end
end

local debug_file
function debug_write(output,trace)
	--[[
	if (trace and debug and type(debug.traceback) == 'function') then
		output = output .. debug.traceback('\n', 2)
	end
	--]]

	if (log) then 
		log(output)
		--get_console():execute("flush")
	end 
end

function is_trader(...)
	local p = {...}
	if p[1]:character_community() == "trader" or p[1]:clsid() == clsid.script_trader or p[1]:clsid() == clsid.trader then
		return true
	end

	if string.find(p[1]:section(),"trader") then
		return true
	end

	local cini = db.storage[p[1]:id()].ini
	local logic = db.storage[p[1]:id()].section_logic

	if not logic and not trader then
		return false
	end

	if cini and logic and cini:section_exist(logic) and cini:line_exist(logic,"trade") then
		return true
	end

	return false
end

function string_to_vector(str)
	if (str == nil or str == "") then 
		return VEC_ZERO
	end
	local t = alun_utils.str_explode(str,",")
	return vector():set(tonumber(t[1] or 0) or 0,tonumber(t[2] or 0) or 0,tonumber(t[3] or 0) or 0)
end

function vector_to_string(vec)
	return vec.x..","..vec.y..","..vec.z
end

function print_packet_data(data)
	local msg = ""
	for kk, vv in pairs(data) do
		if (type(vv) == "userdata" and vv.x and vv.y and vv.z) then
			--m.debug_write("%s: vector:= %s",kk,vec_to_str(vv))
			printf("%s: vector:= %s",kk,vec_to_str(vv))
			msg = msg.."["..kk.."] = "..vector_to_string(vv)
		else
			--m.debug_write("[%s] = %s",kk,vv)
			printf("[%s] = %s",kk,vv)
		end
	end
end

function set_squad_relation(npc,target,rel)
	if not (npc) then
		return
	end

	local squad = get_object_squad(npc)
	if not ( squad ) then
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object
		if ( member and member:alive() ) then
			member:set_relation(rel,target)
		end
	end
end

function set_squad_relation_to_squad(npc,target,rel)
	if not (npc) then
		return
	end

	local squad = get_object_squad(npc)
	if not ( squad ) then
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object
		if ( member and member:alive() ) then
			set_squad_relation(target,member,rel)
			set_squad_relation(member,target,rel)
		end
	end
end

function rand_num(a,b)
	local rnd = math.random
	if (a and b) then
		return rnd(a,b)
	end
	return rnd()
end

function create_squad(section,smart_name)
	local sim = SIMBOARD
	if not (sim) then return end
	local smart = sim.smarts_by_names[smart_name]
	if not (smart) then
		printf("create_squad: no smart by name %s",smart_name)
		return
	end
	local squad = sim:create_squad(smart,section)
	squad.scripted_target = smart_name
	return squad
end

function assign_squad_to_smart(squad_id, id)
	local sim = SIMBOARD
	if not (sim) then return end
	local squad = alife_object(squad_id)
	if not (squad) then return end
	if (squad.smart_id) then
		sim:exit_smart(squad,squad.smart_id)
	end
	sim:assign_squad_to_smart(squad,id)
	--sim:enter_smart(squad,id)
	squad.assigned_target_id = id
	squad.current_action = nil
	squad:get_next_action(false)
end

function get_commander(npc)
	local squad = npc and get_object_squad(npc)
	if (squad and squad:commander_id()) then
		return level.object_by_id(squad:commander_id())
	end
end

function get_squad_commander_action(npc)

	local commander = get_commander(npc)
	local mgr = commander and commander:motivation_action_manager()
	if (mgr and mgr:initialized()) then
		return mgr:current_action_id()
	end
end

function collect_section(ini,section,keytable)
	if not (ini) then
		return
	end
	
	if not (section) then 
		callstack()
		printf("ERROR: collect_section - section does not exist!")
	end

	local _t = {}
	if (section and ini:section_exist(section)) then
		local n = ini:line_count(section)
		if n > 0 then
			for i = 0,n-1 do
				local res,id,val = ini:r_line(section,i,"","")
				if (keytable) then
					if (val == "") then
						val = true
					end
					_t[id] = val or true
				else
					_t[#_t+1] = id
				end
			end
		end
	end
	return _t
end

function get_vertex(npc,dist)
	local rnd1,ang = math.random(100)
	if rnd1 < 43 then
		ang = math.random(50,60)
	elseif rnd1 < 58 then
		ang = math.random(160,200)
	else
		ang = math.random(300,310)
	end
	
	if (accessible(npc,npc:level_vertex_id())) then
		local dir = vector_rotate_y(utils.vector_copy_by_val(npc:direction()),ang)
		return npc:vertex_in_direction(npc:level_vertex_id(),dir,dist)
	end
end


function in_los(npc,friend,be)

	if (friend:id() ~= 0 and npc:target_body_state() ~= move.crouch and IsStalker(friend) and state_mgr.get_state(friend) ~= "prisoner") then
		if (friend:target_body_state() == move.crouch or friend:wounded()) then 
			return false 
		end	
	end

	local pos = alun_utils.safe_bone_pos(npc,"bip01_spine")
	local friend_pos = alun_utils.safe_bone_pos(friend,"bip01_spine")
	local friend_dist = pos:distance_to(friend_pos)
	local be_pos = alun_utils.safe_bone_pos(be,"bip01_spine")
	local dir_aim = vec_sub(be_pos,pos)
	local be_dist = npc:position():distance_to(be:position())

	if (friend_dist < be_dist) then
		local dir_friend = vec_sub(friend_pos,pos)
		local vec_be,vec_who = vector():set(dir_aim):set_length(friend_dist),dir_friend:set_length(friend_dist)
		local mywho = friend_dist < 1.5 and vec_who:similar(vec_be,0) or vec_who:similar(vec_be,1.3)
		if (mywho == 1) then
			return true
		end
	end
	return false
end

function squad_in_los(npc,enemy)
	local squad = get_object_squad(npc)
	if not (squad) then
		return false
	end

	for o in squad:squad_members() do
		local member = db.storage[o.id] and db.storage[o.id].object
		if (member and member:alive()) then
			if (in_los(npc,member,enemy)) then
				return true
			end
		end
	end

	return false
end

function in_crosshair()
	local active_slot = db.actor:active_slot()
	if active_slot == 2 or active_slot == 3	then
		local active_item = db.actor:active_item()
		if active_item and IsWeapon( active_item ) then
			for id,st in pairs(db.storage) do
				local npc = st.object
				if (npc and (IsStalker(npc) or IsMonster(npc)) and npc:alive()) then
					local c = vector():set(npc:position())
					local p = db.actor:position()
					local d = device().cam_dir

					local vpc = vec_sub( c, p )
					
					if vpc:dotproduct( d ) > 0 then	 -- facing right direction
						
						local vec_c = vec_sub( c, p )
						vec_c = vector_rotate_y( vpc, 7 ) -- correct a little bit

						local vec_p = d
						--vec_p:normalize()
						
						local temp1 = vec_p:dotproduct( vec_c ) / ( vec_p:magnitude() )
						
						local temp2 = vec_p
						temp2.x = temp2.x * temp1
						temp2.y = temp2.y * temp1
						temp2.z = temp2.z * temp1
						
						local pc_temp = temp2
													
						local pc = vec_add( p, pc_temp )
															
						local ppp = vec_sub( c, pc )

						if ppp:magnitude() < 0.5 then
							return npc
						end
					end
				end
			end
		end 
	end
end

function npc_in_cover(npc)
	local st = get_storage(npc:id(),"in_cover")
	local tg = time_global()
	if (st.wait or 0) < tg then
		st.wait = tg+300
		local be = npc:best_enemy()
		local enemies = {}
		if be and (not be:clsid() == clsid.script_stalker or not be:wounded()) then
			enemies[1] = be
		else
--			rx_ai.printf("npc_in_cover[%s]:not be",npc:character_name())
			st.evn = true
			return st.evn
		end
		if IsMonster(be) then
			local bee = be:get_enemy()
			if bee and bee:id() == npc:id() then
				st.evn = false
				return st.evn
			end
		end
		local tt = {}
		for o in npc:memory_visible_objects() do
			local obj = o:object()
			local id = obj:id()
			if obj then
--				rx_ai.printf("npc_in_cover[%s]:add enemy[%s]",npc:character_name(),obj:name())
				if (IsStalker(obj) and npc:relation(obj) == game_object.enemy and obj:alive()) then
					if (obj:id() ~= 0 or not obj:wounded()) then 
						enemies[#enemies+1] = obj
					end
				elseif (IsMonster(obj) and npc:relation(obj) == game_object.enemy and obj:alive()) then
					enemies[#enemies+1] = obj
				end
				tt[id] = true
			end
		end
		for o in npc:memory_sound_objects() do
			local obj = o:object()
			local id = obj:id()
			if not tt[id] then
				if obj then
					if (IsStalker(obj) and npc:relation(obj) == game_object.enemy and obj:alive()) then
						if (obj:id() ~= 0 or not obj:wounded()) then 
							enemies[#enemies+1] = obj
						end
					elseif (IsMonster(obj) and npc:relation(obj) == game_object.enemy and obj:alive()) then
						enemies[#enemies+1] = obj
					end
				end
			end
		end
		for i,enemy in ipairs(enemies) do
			local dist = npc:position():distance_to_sqr(enemy:position())
			local seez = enemy:see(npc) or npc:see(enemy)
			local dir = vec_sub(enemy:position(),npc:position())
			local cover
			if npc:body_state() == move.crouch then
				 cover = level.low_cover_in_direction(npc:level_vertex_id(),dir)
			else
				 cover = level.high_cover_in_direction(npc:level_vertex_id(),dir)
			end
			if dist < 25 or (seez and (dist < 80 or cover > 0.4 or (cover > 0.2 and dist < 600))) then
--				rx_ai.printf("npc_in_cover[%s]:enemy![dist = %s,seez = %s,cover = %s]",npc:character_name(),dist,tostring(seez),cover)
				st.evn = false
				st.wait = tg+2000
				return st.evn
			end
		end
		st.evn = true
	end
	return st.evn
end

--------------------------------------addons---------------------------------------
function get_addon_status(wpn,addon)
	if addon == "sc" then
		return wpn:weapon_scope_status()
	elseif addon == "sl" then
		return wpn:weapon_silencer_status()
	elseif addon == "gl" then
		return wpn:weapon_grenadelauncher_status()
	end
	return 0
end

local rep_mem = {}

function get_addon_flag(wpn,with_int)
		local flag = 0
		if wpn:weapon_is_scope() then
			if with_int or get_addon_status(wpn,"sc") == 2 then
				flag = 1
			end
		end
		if wpn:weapon_is_silencer() then
			if with_int or get_addon_status(wpn,"sl") == 2 then
				flag = flag+4
			end
		end
		if wpn:weapon_is_grenadelauncher() then
			if with_int or get_addon_status(wpn,"gl") == 2 then
				flag = flag+2
			end
		end
		return flag
	end

function addon_attached(wpn,addon,flag)
	local ft = {sc = {[1] = true,[3] = true,[5] = true,[7] = true},
				sl = {[4] = true,[5] = true,[6] = true,[7] = true},
				gl = {[2] = true,[3] = true,[6] = true,[7] = true}}
	if ft[addon] then
		return ft[addon][flag or get_addon_flag(wpn,true)] == true
	end
	return false
end

--***************************************
--* save_var(game_object,name,value)
--* load_var(game_object,name,def_value)
--*--------------------------------------
--* Stores/Loads variable with xr_logic's
--* pstor functions.
--***************************************
function save_var(npc,var,val)
	utils.save_var(npc,var,val)
	return val
end

function load_var(npc,var,def)
	return utils.load_var(npc,var,def)
end


---------------------------------------- Path Nodes
class "position_node"
function position_node:__init(amt)
	self.node = {}
	for i=1,amt do
		self.node[i] = {}
	end
end

function position_node:select_best_vertex_id(object,dir,lvid,distance)
	local closest
	for i=1, #self.node do
		if	(bit_and(i,1)) then
			self.node[i].desired_direction = vector_rotate_y(dir, -math.random(50,60))
		else
			self.node[i].desired_direction = vector_rotate_y(dir, math.random(50,60))
		end

		self.node[i].vertex_id = level.vertex_in_direction(lvid, self.node[i].desired_direction, distance)

		if (self.node[i].vertex_id and accessible(object,self.node[i].vertex_id)) then
			self.node[i].distance = self.node[i].vertex_id == lvid and -1 or object:position():distance_to_sqr(level.vertex_position(self.node[i].vertex_id))

			if not (closest) then
				closest = self.node[i].vertex_id
			end

			if (self.node[i-1] and self.node[i-1].distance < self.node[i].distance) then
				closest = self.node[i-1].vertex_id
			end
		end
	end
	return closest and closest ~= -1 and closest
end

-------------------------------------------- INI utils
function get_path(str,sep)
    sep=sep or'\\'
    return str:match("(.*"..sep..")")
end

-- INI Reader
function file_to_table(fname,parent,simple)
	local root = parent and parent.root or {}
	local sec,t,key
	
	local function get_section_includes(str)
		local a = string.find(str,"]")
		return a and " " .. string.sub(str,a+2) or ""
	end

	for line in io.lines(fname) do
		line = trim(trim_comment(line))
		if (line ~= "" and line ~= "\n") then
			if (startsWith(line, "#include")) then
				if (simple ~= true and parent ~= nil) then
					local inc = string.match(line,[["(.-)"]]) or ""
					if (inc ~= "" and file_exists(get_path(fname)..inc)) then
						file_to_table(get_path(fname)..inc,parent,simple)
					end
				end
			elseif (startsWith(line, "[")) then
				sec = string.match(line,"%[(.-)%]")
				
				if (root[sec]) then
					printf("ERROR: Duplicate section exists! %s",line)
				end

				root[sec] = root[sec] or {}

				local inc = trim(get_section_includes(line))
				if (inc and inc ~= "") then
					root[sec]["_____link"] = inc
					if (simple ~= true) then
						local a = str_explode(inc,",")
						for k,v in pairs(a) do
							if (root[v]) then
								for kk,vv in pairs(root[v]) do
									root[sec][kk] = vv
								end
							end
						end
					end
				end
			elseif (sec) then
				key = trim(string.match(line,"(.-)=") or line)
				if (key ~= "") then
					root[sec] = root[sec] or {}
					root[sec][key] = trim(string.match(line,"=(.+)") or "")
				end
			end
		end
	end

	return root
end

function trim_comment(str)
	local a = string.find(str,";")
	return a and trim(string.sub(str,1,a-1)) or str
end

function get_comment(str)
	local a = string.find(str,";")
	return a and " " .. string.sub(str,a) or ""
end

class "cfg_file"
function cfg_file:__init(fname,simple_mode)
	--printf("fname=%s",fname)
	local cfg = io.open(fname,"a+")
	cfg:close()
	self.fname = fname
	self.directory = fname:match("(.*\\)") or ""
	
	self.root = {}
	self.insert = {}
	file_to_table(fname,self,simple_mode)
end

function cfg_file:GetValue(sec,key,typ,def)
	local val = self.root and self.root[sec] and self.root[sec][key]
	if (val == nil) then
		return def
	end

	if (typ == 1 or typ == "bool") then
		return val == "true"
	elseif (typ == 2 or typ == "number") then
		return tonumber(val)
	end
	return val
end

function cfg_file:GetKeys(sec)
	if (self.root and self.root[sec]) then
		local t={}
		for k,v in pairs(self.root[sec]) do 
			if (k ~= "_____link") then 
				t[k] = v
			end
		end
		return t
	end
end

function cfg_file:SetValue(sec,key,val)
	if not (self.root) then
		self.root = {}
	end

	if not (self.root[sec]) then
		self.root[sec] = {}
	end
	
	if (self.root[sec][key] == nil) then
		if not (self.insert[sec]) then 
			self.insert[sec] = {}
		end
		local t = self.insert[sec]
		t[#t+1] = key
	end

	self.root[sec][key] = val == nil and "" or tostring(val)
end

function cfg_file:ClearValue(sec,key)
	if not (self.root) then
		self.root = {}
	end

	if not (self.root[sec]) then
		self.root[sec] = {}
	end
	self.root[sec][key] = nil
end

function cfg_file:SectionExist(sec)
	return self.root and self.root[sec] ~= nil
end

function cfg_file:KeyExist(sec,key)
	return self.root and self.root[sec] and self.root[sec][key] ~= nil
end

-- Save ini by preserving original file. Cannot insert new keys or sections
function cfg_file:SaveExt()
	local t,sec,key,comment
	local str = ""

	local function addTab(s,n)
		local padding = {}
		local l = string.len(s)
		for i=1,n-l do 
			padding[#padding+1] = " "
		end 
		return s .. table.concat(padding)
	end

	for ln in io.lines(self.fname) do
		ln = trim(ln)
		if (startsWith(ln,"[")) then
			-- inject new fields that previously didn't exist
			if (sec and self.root[sec] and self.insert[sec]) then
				for i=1,#self.insert[sec] do
					local k = self.insert[sec][i]
					if (k ~= "_____link") then
						str = str .. addTab(k,40) .. " = " .. tostring(self.root[sec][k]) .. "\n"
					end
				end
			end
			
			sec = string.match(trim_comment(ln),"%[(.-)%]")
			str = str .. ln .. "\n"
		elseif (sec and self.root[sec]) then
			key = trim(trim_comment(string.match(ln,"(.-)=") or ln))
			
			if (key and self.root[sec][key]) then
				comment = get_comment(ln) or ""
				if (comment ~= "") then 
					comment = addTab(comment,20)
				end
				if (self.root[sec][key] == "") then
					str = str .. addTab(key,40) .. " =" .. comment .. "\n"
				else
					str = str .. addTab(key,40) .. " = " .. tostring(self.root[sec][key]) .. comment .. "\n"
				end
			else 
				str = str .. ln .. "\n"
			end
		else 
			str = str .. ln .. "\n"
		end
	end
	
	empty_table(self.insert)
	
	local cfg = io.open(self.fname,"w+")
	cfg:write(str)
	cfg:close()
end

-- Recreates ini as stored in the table and sorted in alphabetical order
function cfg_file:Save()
	local _s = {}
	_s.__order = {}
	
	for section,tbl in pairs(self.root) do
		_s.__order[#_s.__order+1] = section
		if not (_s[section]) then 
			_s[section] = {}
		end
		for k,v in pairs(tbl) do 
			_s[section][#_s[section]+1] = k
		end
	end
	
	table.sort(_s.__order)
	
	for i,section in pairs(_s.__order) do 
		table.sort(_s[section])
	end 
	
	local str = ""
	
	local first
	for i,section in pairs(_s.__order) do
		if not (first) then
			str = str .. "[" .. section .. "]"
			first = true
		else 
			str = str .. "\n[" .. section .. "]"
		end

		if (self.root[section]["_____link"]) then 
			str = str .. ":" .. self.root[section]["_____link"] .. "\n"
		else 
			str = str .. "\n"
		end 

		for ii, key in pairs(_s[section]) do
			if (key ~= "_____link") then
				val = self.root[section][key]
				if (val == "") then
					str = str .. key .. "\n"
				else
					str = str .. key .. " = " .. tostring(val) .. "\n"
				end
			end
		end 
	end 

	local cfg = io.open(self.fname,"w+")
	cfg:write(str)
	cfg:close()
end


--------------------------------
-- XML parser 
--------------------------------
XmlParser = {}
function XmlParser:ToXmlString(value)
	value = string.gsub(value, "&", "&amp;"); -- '&' -> "&amp;"
	value = string.gsub(value, "<", "&lt;"); -- '<' -> "&lt;"
	value = string.gsub(value, ">", "&gt;"); -- '>' -> "&gt;"
	value = string.gsub(value, "\"", "&quot;"); -- '"' -> "&quot;"
	value = string.gsub(value, "([^%w%&%;%p%\t% ])",
		function(c)
			return string.format("&#x%X;", string.byte(c))
		end);
	return value;
end
function XmlParser:FromXmlString(value)
	value = string.gsub(value, "&#x([%x]+)%;",
		function(h)
			return string.char(tonumber(h, 16))
		end);
	value = string.gsub(value, "&#([0-9]+)%;",
		function(h)
			return string.char(tonumber(h, 10))
		end);
	value = string.gsub(value, "&quot;", "\"");
	value = string.gsub(value, "&apos;", "'");
	value = string.gsub(value, "&gt;", ">");
	value = string.gsub(value, "&lt;", "<");
	value = string.gsub(value, "&amp;", "&");
	return value;
end
function XmlParser:ParseArgs(s)
	local arg = {}
	string.gsub(s, "(%w+)=([\"'])(.-)%2", function(w, _, a)
		arg[w] = self:FromXmlString(a);
	end)
	return arg
end
function XmlParser:ParseXmlText(xmlText,path)
	local stack = {}
	local top = {Name=nil,Value=nil,Attributes={},ChildNodes={}}
	table.insert(stack, top)
	local ni,c,label,xarg, empty
	local i, j = 1, 1
	while true do
		ni,j,c,label,xarg, empty = string.find(xmlText, "<(%/?)([%w_:]+)(.-)(%/?)>", i)
		if not ni then break end
		local text = string.sub(xmlText, i, ni-1);
		if not string.find(text, "^%s*$") then
			top.Value=(top.Value or "")..self:FromXmlString(text);
		end
		if empty == "/" then  -- empty element tag
			table.insert(top.ChildNodes, {Name=label,Value=nil,Attributes=self:ParseArgs(xarg),ChildNodes={}})
		elseif c == "" then   -- start tag
			top = {Name=label, Value=nil, Attributes=self:ParseArgs(xarg), ChildNodes={}}
			table.insert(stack, top)   -- new level
		else  -- end tag
			local toclose = table.remove(stack)  -- remove top
			top = stack[#stack]
			if #stack < 1 then
				printf("XmlParser: nothing to close with "..label)
			end
			if toclose.Name ~= label then
				printf("XmlParser: trying to close "..toclose.Name.." with "..label)
			end
			table.insert(top.ChildNodes, toclose)
		end
		i = j+1
	end
	local text = string.sub(xmlText, i);
	if not string.find(text, "^%s*$") then
		stack[#stack].Value=(stack[#stack].Value or "")..self:FromXmlString(text);
	end
	if #stack > 1 then
		printf("XmlParser: unclosed "..stack[stack.n].Name)
	end
	return stack[1].ChildNodes[1];
end
function XmlParser:loadFile(path)
	local hFile, err = io.open(path, "r");
	if hFile and not err then
		local xmlText = hFile:read("*a"); -- read file content
		io.close(hFile);
		return self:ParseXmlText(xmlText), nil;
	else
		printf(err)
		return nil
	end
end

---- utils 
function XmlFindNodeWithAttribute(n,node_name,prop_name,val)
	local node = n.ChildNodes
	local deepest,p,c
	local stack = {}
	while not deepest do
		if (node and #node > 0) then
			for i=1,#node do
				if (node[i].Name == node_name and node[i].Attributes[prop_name] == val) then
					return node[i]
				end
				c = node[i].ChildNodes
				if (c and #c > 0) then
					table.insert(stack,node[i].ChildNodes)
				end
			end
		end

		if (#stack > 0) then
			node = stack[#stack]
			stack[#stack] = nil
		else
			deepest = true
		end
	end
end
function XmlFindNextNodeByName(n,node_name)
	if (n.ChildNodes and #n.ChildNodes > 0) then
		for k,v in pairs(n.ChildNodes) do
			if (v.Name == node_name) then
				return n.ChildNodes[k]
			end
		end
	end
end
function XmlGetNodeValue(n,node_name)
	if (n.ChildNodes and #n.ChildNodes > 0) then
		for k,v in pairs(n.ChildNodes) do
			if (v.Name == node_name) then
				return n.ChildNodes[k].Value
			end
		end
	end
end
function XmlGetNodeAttribute(n,node_name,attribute)
	if (n.ChildNodes and #n.ChildNodes > 0) then
		for k,v in pairs(n.ChildNodes) do
			if (v.Name == node_name) then
				return n.ChildNodes[k].Attributes[attribute]
			end
		end
	end
end
--------
-- end 
--------
function startsWith(text,prefix)
	return string.sub(text, 1, string.len(prefix)) == prefix
end

function w_stpk(stpk,typ,n,info)
	local isError

	if (typ == "bool") then
		if (n and type(n) == "boolean") then
			stpk:w_bool(n)
		elseif (n and type(n) == "string") then
			isError = true
			if (n == "true") then
				stpk:w_bool(true)
			elseif (n == "false") then
				stpk:w_bool(false)
			end
			info = info .. " |-> auto-corrected bool value from string"
		else
			if (n) then
				isError = true
			end
			stpk:w_bool(false)
		end

	elseif (typ == "s8") then
		if (n and type(n) == "number" and n >= -128 and n <= 128) then
			stpk:w_s8(n)
		else
			isError = true
			stpk:w_s8(0)
		end

	elseif (typ == "s16") then
		if (n and type(n) == "number" and n >= -32768 and n <= 32767) then
			stpk:w_s16(n)
		else
			isError = true
			stpk:w_s16(0)
		end

	elseif (typ == "s32") then										
		if (n and type(n) == "number" and n >= -2147483648 and n <= 2147483647) then
			stpk:w_s32(n)
		else
			isError = true
			stpk:w_s32(0)
		end

	elseif (typ == "s64") then
		if (n and type(n) == "number" and n >= -9223372036854775808 and n <= 9223372036854775808) then
			stpk:w_s64(n)
		else
			isError = true
			stpk:w_s64(0)
		end

	elseif (typ == "u8") then
		if (n and type(n) == "number" and n >= 0 and n <= 255) then
			stpk:w_u8(n)
		else
			isError = true
			stpk:w_u8(0)
		end

	elseif (typ == "u16") then
		if (n and type(n) == "number" and n >= 0 and n <= 65535) then
			stpk:w_u16(n)
		else
			isError = true
			stpk:w_u16(0)
		end

	elseif (typ == "u32") then
		if (n and type(n) == "number" and n >= 0 and n <= 4294967295) then
			stpk:w_u32(n)
		else
			isError = true
			stpk:w_u32(0)
		end

	elseif (typ == "u64") then
		if (n and type(n) == "number" and n >= 0 and n <= 18446744073709551615) then
			stpk:w_u64(n)
		else
			isError = true
			stpk:w_u64(0)
		end

	elseif (typ == "float") then
		if (n and type(n) == "number") then
			stpk:w_float(n)
		else
			isError = true
			stpk:w_float(0)
		end

	elseif (typ == "stringZ") then
		if (n and type(n) == "string") then
			if (string.len(n) > 255) then
				isError = true
				info = info .. " |-> length of string is too long for stringZ"
			end
			stpk:w_stringZ( string.sub(n,0,255) )
		elseif (n and type(n) ~= "userdata") then
			stpk:w_stringZ(tostring(n))
		else
			--isError = true
			stpk:w_stringZ("nil")
		end

	elseif (typ == "CTime") then
		utils.w_CTime(stpk,n)
		--[[
		if (n and type(n) == "userdata" and n.timeToString) then
			utils.w_CTime(stpk,n)
		else
			--printf("w_stpk:Debug: CTime is nil [%s]",info)
			utils.w_CTime(stpk,nil)
		end
		--]]
	else
		isError = true
	end

	if (isError) then
		printf("w_stpk:CRITICAL ERROR: write %s (%s) TrueType=%s [%s]   | Packet:w_tell()=>%s",typ,type(n) ~= "userdata" and tostring(n) or "userdata",type(n),info,stpk:w_tell())
	else
		--printf("w_stpk:DEBUG: write %s (%s) TrueType=%s [%s]   | Packet:w_tell()=>%s",typ,type(n) ~= "userdata" and tostring(n) or "userdata",type(n),info,stpk:w_tell())
	end
end

function findfunction(x,tbl)
	assert(type(x) == "string")
	local f=tbl
	for v in x:gmatch("[^%.]+") do
		if type(f) ~= "table" then
			printf("looking for '%s' expected table, not %s",v,type(f))
			return
		end
		f=f[v]
	end
	if type(f) == "function" then
		return f
	else
		printf("expected function, not %s",type(f))
		return nil
	end
end

local fsgame
function get_fsgame()
	if (fsgame) then
		return fsgame
	end

	local root = {}
	file_to_table("fsgame.ltx",root,true)

	local fsgame = {}
	fsgame["$fs_root$"] = ""
	local t
	for k,v in pairs(root) do
		t = str_explode(v,"|")
		dir = t[3]

		if not (string.find(dir,"%$")) then
			fsgame[k] = (dir or "") .. (t[4] or "")
		else
			fsgame[k] = t[4] or ""
		end

		repeat
			t = root[dir] and str_explode(root[dir],"|")
			dir = t and t[3]
			fsgame[k] = (fsgame[dir] or dir or "") .. (t and t[4] or "") .. fsgame[k]
		until (dir == nil)
	end
	return fsgame
end

function fspath(str)
	local fsg = get_fsgame()
	return fsg[str] or ""
end

function fsgame_append(str,ap)
	if (fspath(str) ~= "" and fspath(str) ~= nil) then
		return
	end
	fsgame = nil

	local fsg = io.open("fsgame.ltx","a+")
	local data = fsg:read("*all")
	if not (string.find(data,str)) then
		fsg:write("\n"..ap)
	end
	fsg:close()
end

function CTime2table(gt)
	if not (gt) then
		return
	end

	local t = {}
	t.y, t.m, t.d, t.h, t.m, t.s, t.ms = 0, 0, 0, 0, 0, 0, 0
	t.y, t.m, t.d, t.h, t.m, t.s, t.ms = gt:get( t.y, t.m, t.d, t.h, t.m, t.s, t.ms )
	t.y = t.y - 2000
	return t
end

function table2CTime(t)
	if not (t and t.y and t.m and t.d and t.h and t.m and t.s and t.ms) then
		return
	end

	local gt = game.CTime()
	gt:set( t.y + 2000,  t.m, t.d, t.h, t.m, t.s, t.ms)
	return gt
end

function find_random_cover(npc,pos,min_rad,max_rad)
	local rnd = math.random
	local base_point = npc:level_vertex_id()
	local base_vertex_id = level.vertex_in_direction(base_point, vector_rotate_y(utils.vector_copy_by_val(npc:direction()),rnd(0,360)), rnd(min_rad,max_rad))
	local base_position = level.vertex_position(base_vertex_id)

	local cover, tcover
	local cover_dist = 15
	while not cover and cover_dist > 0 do
		cover = npc:best_cover(base_position,pos,cover_dist,5,15)
		cover_dist = cover_dist - 1
	end

	return cover and valid_vertex(npc,cover:level_vertex_id())
end

local function validate(npc,vid)
	if (vid and vid < 4294967295 and npc:accessible(vid) and vid ~= npc:level_vertex_id()) then 
		return db.used_level_vertex_ids[vid] == nil or db.used_level_vertex_ids[vid] == npc:id()
	end 
	return false
end

-- find nearest cover
function find_close_cover(npc,base_position,pos,cover_dist,mn,mx)
	local cover
	cover_dist = not cover_dist and 5 or cover_dist
	while not cover and cover_dist < 30 do
		cover = npc:best_cover(base_position,pos,cover_dist,mn or 1,mx or 60)
		if (cover) and not (validate(npc,cover:level_vertex_id())) then 
			cover = nil 
		end
		cover_dist = cover_dist + 1
	end
	
	return cover and valid_vertex(npc,cover:level_vertex_id())
end

function find_cover_in_rand_direction(npc,base_point,pos)
	local rnd = math.random
	
	local dir = npc:direction()
	local rand_dir = rnd(1,6)
	local base_vertex_id, base_position, cover, cover_dist
	for i=rand_dir,6 do
		base_vertex_id = level.vertex_in_direction(base_point,dir,i*60)
		base_position = level.vertex_position(base_vertex_id)

		cover = nil
		cover_dist = rnd(1,30)
		while not cover and cover_dist > 0 do
			cover = npc:best_cover(base_position,pos,cover_dist,1,30)
			cover_dist = cover_dist - 1
		end
		
		if (cover and valid_vertex(npc,cover:level_vertex_id())) then 
			return valid_vertex(npc,cover:level_vertex_id())
		end
	end

	return valid_vertex(npc,base_vertex_id)
end

function try_go_backward(npc,radius,old_vid)
	--alun_utils.debug_nearest(npc,"try_go_backward")
	local dir = vector_rotate_y(utils.vector_copy_by_val(npc:direction()),math.random(160,200))
	local vid
	local base_point = npc:level_vertex_id()
	while (radius > 0) do
		vid = level.vertex_in_direction(base_point,dir,radius)
		if (validate(npc,vid)) then
			return alun_utils.lmove(npc,vid,old_vid)
		end
		radius = radius - 2
	end
end 

function try_go_aside_object(npc,friend,pos,old_vid)
	if not (friend) then 
		return 
	end 
	
	local mypos = npc:position()
	
	if (mypos:distance_to_sqr(friend:position()) < 3) then 
		return 
	end

	--alun_utils.debug_nearest(npc,"try_to_strafe")
	local _dir = vec_sub(mypos,pos)
	local dir = {}
	dir[1] = vector_rotate_y(utils.vector_copy_by_val(_dir),-90)
	dir[2] = vector_rotate_y(utils.vector_copy_by_val(_dir),90)
	local vid
	local radius = 12
	local base_point = friend:level_vertex_id()
	
	for i=1,2 do
		while (radius > 0) do
			vid = level.vertex_in_direction(base_point,dir[i],radius)
			if (validate(npc,vid)) then 
				return alun_utils.lmove(npc,vid,old_vid)
			end
			radius = radius - 2
		end
	end
end 

function try_go_position(npc,pos,old_vid)
	local vid = level.vertex_id(pos)
	if (validate(npc,vid)) then 
		return alun_utils.lmove(npc,vid,old_vid)
	end 
end 

function try_go_cover(npc,pos,old_vid,r)
	local vid = alun_utils.find_close_cover(npc,npc:position(),pos,r or 8)
	return validate(npc,vid) and alun_utils.lmove(npc,vid,old_vid)
end 

function try_to_strafe(npc,old_vid)
	local _dir = npc:direction()
	local dir = {}
	dir[1] = vector_rotate_y(utils.vector_copy_by_val(_dir),-90)
	dir[2] = vector_rotate_y(utils.vector_copy_by_val(_dir),90)
	local vid
	local radius = 10
	local base_point = npc:level_vertex_id()
	
	for i=1,2 do
		while (radius > 0) do
			vid = level.vertex_in_direction(base_point,dir[i],radius)
			if (validate(npc,vid)) then 
				return lmove(npc,vid,old_vid)
			end
			radius = radius - 2
		end
	end
end 

function lmove(npc,vid,old_vid)
	if (old_vid) then 
		db.used_level_vertex_ids[old_vid] = nil
	end
	
	if (vid == nil or vid >= 4294967295) then 
		return 
	end
	
	if (db.used_level_vertex_ids[vid] == npc:id()) then
		npc:set_dest_level_vertex_id(vid)
		return vid 
	end
	
	if not (npc:accessible(vid)) then
		local vtemp = vector():set(0,0,0)
		vid, vtemp = npc:accessible_nearest(vid and level.vertex_position(vid) or npc:position(), vtemp )
	end

	db.used_level_vertex_ids[vid] = npc:id()

	npc:set_dest_level_vertex_id(vid)
	return vid
end

function sqrMagnitude(vec)
	return (vec.x^2)+(vec.y^2)+(vec.z^2) 
end

function in_los(npc,be,friend)

	if (npc:target_body_state() ~= move.crouch) then
		return false 
	end 
	
	if (IsWounded(friend)) then 
		return false 
	end

	local be_pos = alun_utils.safe_bone_pos(be,"bip01_spine")
	local pos = alun_utils.safe_bone_pos(npc,"bip01_spine")
	local friend_pos = alun_utils.safe_bone_pos(friend,"bip01_spine")
	local friend_dist = pos:distance_to(friend_pos)
	local dir_aim = vec_sub(be_pos,pos)
	local be_dist = npc:position():distance_to(be:position())

	if (friend_dist < be_dist) then
		local dir_friend = vec_sub(friend_pos,pos)
		local vec_be,vec_who = vector():set(dir_aim):set_length(friend_dist),dir_friend:set_length(friend_dist)
		local mywho = friend_dist < 1.5 and vec_who:similar(vec_be,0) or vec_who:similar(vec_be,1.3)
		if (mywho == 1) then
			return true
		end
	end
	return false
end

function friends_on_fire_line(npc,be,st)
	if not (st.__ff_index) then
		st.__ff_index = 1
	end
	
	if not (db.OnlineStalkers) then 
		return 
	end

	local size = #db.OnlineStalkers
	
	if (size == 0) then
		return false 
	end 
	
	-- iterate only 5 steps at a time to ease cpu when tons of npcs online
	for i=1,5 do
		if (st.__ff_index > size) then
			st.__ff_index = 1
			return false
		end

		local id = db.OnlineStalkers[st.__ff_index]
		st.__ff_index = st.__ff_index + 1

		local sid = npc:id()
		local friend = id  and id ~= sid and db.storage[id] and db.storage[id].object
	
		if (friend and friend:alive() and npc:relation(friend) < game_object.enemy) then
			local pos = alun_utils.safe_bone_pos(npc,"bip01_spine")
			local friend_pos = alun_utils.safe_bone_pos(friend,"bip01_spine")
			local friend_dist = pos:distance_to(friend_pos)
			local be_pos = alun_utils.safe_bone_pos(be,"bip01_spine")
			local dir_aim = vec_sub(be_pos,pos)
			local be_dist = npc:position():distance_to(be:position())

			if (friend_dist < be_dist) then
				local dir_friend = vec_sub(friend_pos,pos)
				local vec_be,vec_who = vector():set(dir_aim):set_length(friend_dist),dir_friend:set_length(friend_dist)
				local mywho = friend_dist < 1.5 and vec_who:similar(vec_be,0) or vec_who:similar(vec_be,1.3)
				if (mywho == 1) then
					st.friend_id = id
					return true
				end
			end
		end
	end

	return false
end
--[[
class "BezierPath"
function BezierPath:__init() 
	self.SEGMENTS_PER_CURVE = 10
	self.MINIMUM_SQR_DISTANCE = 0.01
	self.DIVISION_THRESHOLD = -0.99
	self.controlPoints = {}
	self.curveCount = 0
end 

-- Sets the control points of this Bezier path.
-- Points 0-3 forms the first Bezier curve, points 
-- 3-6 forms the second curve, etc.
function BezierPath:SetControlPoints(newControlPoints)
	empty_table(self.controlPoints)
	self.controlPoints = newControlPoints
	self.curveCount = (#self.controlPoints-1)/3
end 

-- returns the control points for this Bezier curve
function BezierPath:GetControlPoints()
	return self.controlPoints
end

-- Calculates a Bezier interpolated path for the given points.
function BezierPath:Interpolate(segmentPoints,scale)
	empty_table(self.controlPoints)
	
	if (#segmentPoints < 2) then 
		return 
	end
	
	for i=1, #segmentPoints, 1 do 
		if (i == 1) then 
			local p1 = segmentPoints[i]
			local p2 = segmentPoints[i+1]
			
			local tangent = vec_sub(p2,p1)
			local q1 = p1:add(tangent:mul(scale))
			
			table.insert(self.controlPoints,p1)
			table.insert(self.controlPoints,q1)
		elseif (i == #segmentPoints) then
			local p0 = segmentPoints[i]
			local p1 = segmentPoints[i+1]
			
			local tangent = vec_sub(p1,p0)
			local q0 = p1:add(tangent:mul(scale))
			
			table.insert(self.controlPoints,q0)
			table.insert(self.controlPoints,p1)
		else
			local p0 = segmentPoints[i-1]
			local p1 = segmentPoints[i]
			local p2 = segmentPoints[i+1]
			
			local tangent = vec_sub(p2,p0):normalize()
			
			local q0 = vec_sub(p1,tangent:mul(scale):mul( vec_sub(p1,p0):magnitude() ))
			local q1 = vec_add(p1,tangent:mul(scale):mul( vec_sub(p2,p1):magnitude() ))
			
			table.insert(self.controlPoints,q0)
			table.insert(self.controlPoints,p1)
			table.insert(self.controlPoints,q1)
		end
	end
	self.curveCount = (#self.controlPoints-1)/3
end

-- Sample the given points as a Bezier path.
function BezierPath:SamplePoints(sourcePoints,minSqrDistance,maxSqrDistance,scale)
	if (#sourcePoints < 2) then 
		return 
	end 
	
	local samplePoints = {}
	table.insert(sourcePoints[1])
	
	local potentialSamplePoint = sourcePoints[2]
	
	for i=3, #sourcePoints, 1 do 
		if ( sqrMagnitude(vec_sub(potentialSamplePoint,sourcePoints[i])) > minSqrDistance ) then 
			if ( sqrMagnitude(vec_sub(samplePoints[#samplePoints],sourcePoints[i])) > maxSqrDistance ) then 
				table.insert(samplePoints,potentialSamplePoint)
			end		
		end 
		potentialSamplePoint = sourcePoints[i]
	end
	
	-- now handle last bit of curve
	local p1 = samplePoints[#samplePoints]
	samplePoints[#samplePoints] = nil 
	
	local p0 = samplePoints[#samplePoints]
	local tangent = vec_sub(p0,potentialSamplePoint):normalize()
	
	local d2 = vec_sub(potentialSamplePoint,p1):magnitude()
	local d1 = vec_sub(p1,p0):magnitude()
	
	p1 = vec_add(p1, tangent:mul((d1-d2/2)))
	
	table.insert(samplePoints,p1)
	table.insert(samplePoints,potentialSamplePoint)
	
	self:Interpolate(samplePoints,scale)
end 

-- Caluclates a point on the path.
--
-- @param curveIndex The index of the curve that the point is on. For example, 
-- the second curve (index 1) is the curve with controlpoints 3, 4, 5, and 6.
--
-- @param t The paramater indicating where on the curve the point is. 0 corresponds 
-- to the "left" point, 1 corresponds to the "right" end point.
function BezierPath:CalculateBezierPoint(curveIndex,t)
	local nodeIndex = curveIndex * 3

	local p0 = self.controlPoints[nodeIndex]
	local p1 = self.controlPoints[nodeIndex + 1]
	local p2 = self.controlPoints[nodeIndex + 2]
	local p3 = self.controlPoints[nodeIndex + 3]

	return self:CalculateBezierPoint(t, p0, p1, p2, p3)
end

-- Gets the drawing points. This implementation simply calculates a certain number
-- of points per curve

function BezierPath:GetDrawingPoints0()
	local drawingPoints = {}
	
	for curveIndex=1, self.curveCount, 1 do 
		if (curveIndex == 1) thne 
			table.insert(drawingPoints,CalculateBezierPoint(curveIndex,0))
		end
		for j=1, self.SEGMENTS_PER_CURVE, 1 do 
			local t = j/self.SEGMENTS_PER_CURVE
			table.insert(drawingPoints,self:CalculateBezierPoint(curveIndex,t))
		end
	end
	
	return drawingPoints
end

-- slightly different than above
function BezierPath:GetDrawingPoints1()
	local drawingPoints = {}
	
	for i=1, #self.controlPoints-3, 3 do 
		local p0 = self.controlPoints[nodeIndex]
		local p1 = self.controlPoints[nodeIndex + 1]
		local p2 = self.controlPoints[nodeIndex + 2]
		local p3 = self.controlPoints[nodeIndex + 3]
		
		if (i == 1) then 
			table.insert(drawingPoints,self:CalculateBezierPoint(0,p0,p1,p2,p3))
		end
		
		for j=1, SEGMENTS_PER_CURVE, 1 do 
			local t = j/SEGMENTS_PER_CURVE
			table.insert(CalculateBezierPoint(t,p0,p1,p2,p3))
		end
	end

	return drawingPoints
end

-- returns the number of points added.
function BezierPath:FindDrawingPoints(curveIndex,t0,t1,pointList,insertionIndex)
	local left = CalculateBezierPoint(curveIndex, t0)
	local right = CalculateBezierPoint(curveIndex, t1)
	
	if ( sqrMagnitude(vec_sub(left,right)) < self.MINIMUM_SQR_DISTANCE ) then 
		return 0
	end
	
	local tMid = (t0+t1)/2
	local mid = CalculateBezierPoint(curveIndex,tMid)
	
	local leftDirection = vec_sub(left,mid):normalize()
	local rightDirection = vec_sub(right,mid):normalize()
	
	if (leftDirection:dotproduct(rightDirection) > self.DIVISION_THRESHOLD or math.abs(tMid - 0.5) < 0.0001) then 
		local pointsAddedCount = 0
		
		pointsAddedCount = pointsAddedCount + self:FindDrawingPoints(curveIndex,t0,tMid,pointList,insertionIndex)
		table.insert(pointList,insertionIndex+pointsAddedCount,mid)
		pointsAddedCount = pointsAddedCount + 1 
		pointsAddedCount = pointsAddedCount + self:FindDrawingPoints(curveIndex,tMid,t1,pointList,insertionIndex+pointsAddedCount)
		return pointsAddedCount
	end
	
	return 0 
end 

-- Caluclates a point on the Bezier curve represented with the four controlpoints given.
function BezierPath:CalculateBezierPoint(t,p0,p1,p2,p3)
	local u = 1 - t
	local tt = t*t 
	local uu = u*u 
	local uuu = uu*u 
	local ttt = tt*t
	
	local p = vector():set(p0):mul(uuu)
	
	p:add(vector():set(p1):mul(uu*t) )
	p:add(vector():set(p2):mul(tt*u) )
	p:add(vector():set(p3):mul(ttt) )
	
	return p
end
--]]

local function within(a,b,c)
	return a <= b and a <= c or c <= b and c <= a
end 

function vec_collinear(a,b,c)
	return (b.x-a.x)*(c.y-a.y) == (c.x-a.x)*(b.y-a.y)
end 

function vec_intersects_line(a,b,c)
	if (within(a.x, c.x, b.x)) then 
		if (a.x ~= b.x) then 
			return vec_collinear(a,b,c)
		elseif (within(a.y,c.y,b.y)) then
			return vec_collinear(a,b,c)
		end
	end
end